1. 대안 : 공유 핸들러 함수 생성하기
이벤트 속성 = {(event)=>{공유Func()}}를 작성하면 이벤트가 발생할 떄마다 공유 Func이 작동한다.
=> 리액트에서 이벤트 핸들러의 매개변수는 event 하나만 전달된다. 나머지는 무시된다. 그러나 공유 Func은 매개변수를 자유롭게 줄 수 있다. 즉, 내가 원하는 로직대로 이벤트 핸들러를 작동시킬 수 있는 것이다.


2. 양식 제출 처리하기
button의 type이 submit이고 form 요소 안에서 클릭되면 form 요소 자체에서 이벤트를 발생시킨다.
=> 그 이벤트가 <form onSubmit = {}>이다.
=> 이 이벤트의 기본동작은 전송시 새로고침이다.

*** useState의 setFunc()으로 값을 변경하면 그 값은 initValue로 받는다. 다만 그 값은 console에는 즉시 처리되지 않는다.
컴포넌트를 재평가할 떄 위에서 아래로 읽기 떄문에 JS코드 읽고 JSX가 반환되기 때문이다.


3. 양방향 바인딩 추가하기

HTML input 속성
1. input의 type이 text나 password일 떄 value를 설정하면 초기 글자를 미리 입력해둘 수 있다. 
2. 서버에 제출될 떄 value 속성이 전달된다.

* input이 제출되면 input의 내용물을 지우고 싶다. => 제출할 떄의 이벤트에 setFunc('')를 작성한다. => input의 value는 초기값을 보여주는 것이기 떄문에 value={initValue}를 작성하면 제출될 떄마다 인풋의 내용물을 지워준다.
=> input의 값이 빈 문자열이라면 value 값을 보여준다.


4. 자식 - 부모 컴포넌트 통신 (상향식)
하위 컴포넌트에서 테이터를 수집하면 상위 컴포넌트에게 데이터를 전달할 필요가 있다.
(props는 부모와 자식 사이에서만 전달이 가능하고 중간 컴포넌트를 뛰어넘을 수 없다.)

1. 상위 컴포넌트에서 하위 컴포넌트 태그 속성을 지정한다.
2. 그 속성은 함수이며 함수 포인터만 넘긴다.
3. 하위 컴포넌트에서 상위 컴포넌트가 넘긴 함수가 호출되면 상위 컴포넌트에서 사용한 것처럼 데이터가 전달된다.
=> 하위에서 상위로 데이터가 전달된다.


5. 상태 위로 올리기
형제 형태의 컴포넌트는 직접적으로 데이터 전달이 불가능하다. => 그래서 데이터를 위로 이동시킨다.
무조건 App.js까지 데이터를 끌어올리는 것은 아니다. 데이터가 필요한 컴포넌트와 데이터를 수집하는 컴포넌트의 교차 부모 컴포넌트까지 데이터를 올리면 된다. 그리고나서 데이터가 필요한 컴포넌트에 내려주면 된다.


6~7. 연습하기 : 이벤트 및 State 작업하기
select Tag는 사용자가 드롭다운 메뉴를 클릭해서 새로운 값을 선택할 떄마다 변경 이벤트를 만든다.
=> onChange를 통해서, select은 onChange 프로퍼티를 가지고 있다.


8. 파생/ 계산된 상태(파생된 값/ 계산된 값)
설정하는 상태가 다른 상태와 직접적으로 연결된다면 별도의 상태로 관리하는 건은 합리적이지 않다.
=> 상태가 업데이트 되면 해당 컴포넌트가 모조리 재실행되는 원리를 이용한다.

useState로 관리되는 값을 이용하는 개념이 => 파생된 값(계산된 값)을 이용한다고 한다.

ex) setFunc()으로 인해 데이터가 변경되면 컴포넌트가 재실행된다. 이를 이용하여 상태관리를 중복하지 않고 데이터를 변경한다. initValue를 이용해 initValue가 바뀌는 시점에 다른 데이터 변경을 요청하면 setFunc()의 의해 컴포넌트 재평가로 useState로 관리된 값이나 또 다른 값이 변경된다.


9. 제어 컴포넌트 VS 비제어 컴포넌트, 상태 비저장 컴포넌트 VS 상태 저장 컴포넌트


































