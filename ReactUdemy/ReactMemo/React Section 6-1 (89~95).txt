1. 데이터 렌더링 목록
=> props로 넘어오는 값들은 얼마나 존재할지 모른다.
=> 동적인 데이터 출력이 가능해야 한다.
=> Array.map를 사용하여 사용자 지정 컴포넌트를 반환한다.

props로 하위 컴포넌트에 값들을 보냈다면 {} JSX 동적 표현식 중괄호 안에 map 구문를 작성하면 동적으로 데이터를 출력시킬 수 있다.

props.item(key).map((expense) => {
   <ExpenseItem title={expense.title} date={expense.date} amount={expense.amount}/>
})
=> 이런 구문을 작성하면 데이터를 동적으로 출력시킬 수 있다.


2. State 저장 목록 사용
setFunc()를 사용하여 리렌더링을 하면 하위 컴포넌트까지 모조리 리렌더링의 대상이 된다.
=> 이 때문에 화면단을 구성하는 컴포넌트의 데이터가 화면에 반영되는 것이다.

이전 값에 기대어 리렌더링은 setFunc(callback)를 사용하는 것이 좋다.
callback은 자동으로 이전 스냅샷의 데이터를 매개변수에 갖고 있다.

3. keys 이해하기
리액트는 새로운 데이터를 업데이트할 떄 새로운 데이터를 마지막 요소로 렌더링하고 모든 데이터들을 업데이트해서 컨텐츠를 교체한다. => 이렇게 해서 해당 리액트 프로젝트의 배열순서를 일치시킨다.
=> 리액트에게는 모든 아이템이 비슷해보이고 배열이 길어진 것만 인식하기 떄문에 이런 로직이 실행된다.
=> 새로운 데이터가 렌더링되어야 한다면 가장 밑에 두고 모든 컨텐츠를 순회하여 업데이트하여 배열의 순서에 맞게 보여준다.
=> 성능 측면에서 좋지 않다.
=> 배열의 순서를 따르게 하는 것이 아니라 새로운 데이터들이 어디에 추가되어야 하는지 리액트에게 알려줘야 한다.

위의 사안을 해결하기 위해 key props를 사용한다. 이 키를 통해 리액트가 개별 데이터를 인식할 수 있도록 도와준다.
키={}의 값은 숫자나 문자열 등 고유한 데이터면 아무거나 가능하다.
고유한 키를 갖게되면 React는 데이터가 위치해야 할 곳을 정확히 파악하고 불필요한 업데이트를 하지 않고 들어오는 데이터만 업데이트하게 된다.


4. 연습하기 : 목록 작업하기
리렌더링의 시점을 잘 파악해야 한다. setFunc()으로 인해 select 박스의 연도가 바뀌면 해당 컴포넌트의 코드가 재해석되고 재실행된다. 이 시점에서 변경된 데이터가 화면에 출력되는 것이다. 그렇기 때문에 불필요한 상태관리를 한 번 더 하지 않아도 된다.
=> setFunc()으로 인해 변경된 데이터를 따와서 다른 데이터를 변경하는데 사용할 수 있다는 것이다.


5. 조건부 내용 출력하기
컨텐츠를 조건부로 렌더링할 필요성이 있다. => 상황에 맞춰서 렌더링을 해야 한다.
JSX 표현식에서 if문이나 for문를 사용하지 않는다. => 삼항 조건문이나 조건부 표현식을 사용한다.
삼항 조건문은 자동으로 결과가 return 된다.
=> and 속성을 이용해서 마지막 true를 렌더링한다.

컴포넌트 return문 위에서 변수에 JSX 컨텐츠를 저장할 수 있다. => 이를 이용해서 JSX 표현식의 구문을 줄일 수 있다.
또한 JSX 표현식에서는 if문과 for문를 사용할 수 없기 떄문에 동적 반환이 어렵지만 일반 JS로 표현식 구문를 만들면 쉽게 구현할 수 있다.


6. 조건 명령문 반환 추가하기
조건 명령문의 JS 로직은 따른 컴포넌트에서 관리해주는 것이 좋다.
조건 컴포넌트는 삼항문이나 조건문, 연산자들을 조합하거나 고려하여 사용해야 한다.
JSX는 JS에서 변수의 값으로 할당할 수 있다. => 컴포넌트나 HTML태그들을 변수에 할당시킬 수 있다는 것이다.


7. 연습하기 : 조건부 컨텐츠
























