1. Sid Effets란 무엇이며 useEffect는 무엇인가? (effect = SideEffect)
React의 주요 임무는 사용자의 입력을 받아서 UI를 렌더링하는 것이다. => JSX 코드와 DOM를 평가하며 렌더링한다.

사이드 이펙트는 애플리케이션에서 일어나는 다른 모든 것을 뜻한다.(http 요청, 브라우저 저장소 저장 등...)
이러한 사이드 이펙트들은 일반적인 컴포넌트 평가의 밖에서 일어나야 하는 일이다.

State가 변경되면 컴포넌트를 재평가하여 실제 DOM과 변경된 컴포넌트의 차이를 실제 DOM에서 약간의 변경을 한다.
HTTP 요청을 State를 바꾸게 되면 무한 루프에 빠질 수 도 있다. 따라서 SideEffect는 직접적으로 컴포넌트 함수에 들어가서는 안된다.

위의 사안을 해결하기 위한 useEffect()를 사용한다. useEffect는 두 개의 인수와 같이 호출된다.
첫 번쨰 인수는 함수이다. 모든 컴포넌트 평가 후에 실행되어야 하는 함수이다. 두 번쨰 인수는 의존성 배열이다. 두 번쨰 인수의 의존성이 변경될 때마다 첫 번쨰 함수가 다시 실행된다. 이 떄는 지정한 의존성이 변경된 경우에만 실행된다. 컴포넌트가 다시 렌더링될 떄는 실행되지 않는다.

side Effect
1. 함수 내에서 동일한 입력에 대해 같은 결과를 보장 할 수 없는 것
2. 함수 실행 과정에서 외부의 값을 변경하는 것


2. useEffect() 훅 사용하기
리액트 프로젝트에서 새로고침을 하면 얻은 모든 변수가 사라진다. => 웹의 작동방식
앱이 시작할 때마다 데이터가 유지되었는지 확인하는 로직이 필요하다. => 이를 통해서 새로고침해도 데이터를 유지시킨다.
=> 이를 위해서 useEffect와 쿠키 or LocalStorage를 사용한다.

1. logIn할 떄(로그인 핸들러에서) localStorage.setItem()를 통해서 key-value 형식으로 localStorage에 저장한다.
2. 로그인 할 떄마다 (컴포넌트 재실행) if check를 통해 local의 value를 확인하고 setFunc(true)를 통해 로그인 됐음을 알린다.
=> 이 방식은 무한 푸프이다. useEffect()를 통해 언제 실행될지를 제어해야 한다.

useEffect()는 해당 컴포넌트 재평가 후에 or 평가 후에 JSX를 리턴하고 DOM에 반영된 뒤에 실행된다. 이 떄 의존성이 변경된 경우에만 실행된다.
uesEffect의 2번 쨰 인자에 빈 배열을 주면 처음 실행될 때만 useEffect의 첫 번쨰 함수가 실행된다.
=> 컴포넌트 함수가 처음으로 실행되면 두 번쨰 인자의 빈 배열이라도 의존성이 변경된 것으로 간주된다. => 처음부터 의존성이 존재하지 않았기 때문이다. 그 이후로는 의존성이 ([]) 그대로이기 때문에 useEffect()이 재실행되지 않는다.

*** 평가와 렌더링은 다른 의미이다. 평가나 재평가가 완료되어 JSX 코드가 반환되면 그 떄 Rendering 하는 것이다.


useEffect()의 실행시점
** useEffect의 실행은 컴포넌트 렌더링이 끝난 후에 useEffect()가 실행된다.


3. useEffect & 종속성
만약 useEffect의 의존성 배열이 없다면 useEffect의 실행 함수는 컴포넌트가 다시 렌더링될 때마다 다시 실행된다.
=> 무한 루프가 발생한다.

useState의 setFunc()는 리액트에 의해 절대 변경되지 않도록 보장한다.

Side Effect는 어떤 요청이 와서 새로운 값을 응답하는 상황이나 경우를 의미한다.

** useEffect의 종속성 배열에서 값이 변경되지 않는 것을 넣는 것은 불필요하다. 함수나 내장 API를 넣을 필요가 없다.


4. useEffect 에서 CleanUp 함수 사용하기
useEffect()를 통해 setFunc()를 사용할 떄 의존성 배열의 값이 변경될 때마다 state 변경을 하는 것은 불필요할 수 있다.
=> 몇 초마다, 얼마나의 시간을 두고 setFunc()를 할 수 있다면? => 디바운싱이라고 부르는 기술이 있다.

useEffect()는 무엇가를 return 할 수 있다. 함수 자체여야 한다.
이를 클린업 함수라고하고 클린업 프로세스로써 실행된다.
클린업 함수는 useEffect 함수가 실행되기 전에 클린업 함수가 실행된다.

클린업 함수는 모든 새로운 사이드이펙트 함수가 실행되기 전에, 그리고 컴포넌트가 제거되기 전에 실행된다. 그리고 첫 번쨰 사이드이펙트 함수가 실행되기 전에는 실행되지 않는다.

clearTimeout은 setTimeout으로 몇 초 후에 실행할 함수를 제거하는 것이다.

ex) 
1. useEffect의 첫 번쨰 인자는 의존성 배열의 변경 여부에 의해 실행되는 사이드 이펙트 함수이다. 이 함수에서 setTimeout를 설정하고 변수에 집어넣는다. setTimeout은 500마다 setFunc()를 실행하도록 한다.

2. 첫 번쨰 인자 밑에서 return를 사용해서 클린업 함수를 사용한다. clearTimeout를 통해 setTimeout에서 설정한 변수명을 집어넣는다. => clearTimeout은 setTimeout이 실행할 함수를 제거한다.

3. 클린업 함수는 useEffect()의 첫 인자 함수가 실행되기 전에 실행된다. 의존성 배열은 키 입력을 받으면 트리거 되는 state이다. 키 입력 => 의존성 배열 변경 => useEffect()의 클린업 함수 실행 => useEffect() 첫 번쨰 인자 함수 실행

이 떄 클린업 함수는 clearTimeout를 호출한다. 즉 시간이 500가 지난 마지막 키 입력만 useEffect()가 실행된다는 것이다.


5. useEffect() 요약

5-1. useEffect()의 두 번쨰 인자에 의존성 배열이 아예 존재하지 않을 경우
=> 처음으로 렌더링 될 떄, useEffect가 실행된다.
=> 컴포넌트 함수가 다시 실행될 때마다 실행된다. (state 변경 이후에 해당 컴포넌트가 재실행 되기 때문이다.)

5-2. useEffect(()=>{}, []);
=> 처음으로 렌더링된 이후에만 실행되고 이후에는 실행되지 않는다.

5-3. useEffect(()=>{}, [....])
=> 의존성 배열이 변경될 때마다 실행된다.

5-4. useEffect(()=>{} return )
해당 컴포넌트가 DOM에서 제거되면 cleanUp 함수가 실행된다.
























