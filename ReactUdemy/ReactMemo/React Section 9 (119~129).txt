1. 첫 번쨰 연습 프로젝트 및 작업

1-1. 여러 개의 컴포넌트로 분할한다.
1-2. 이벤트를 처리한다.
1-3. 상태를 관리한다.
1-4. 조건부로 데이터를 표시한다.
1-5. Styling


2. 앱을 컴포넌트로 분할하기
현재 App.js는 크게 3가지로 나뉠 수 있다. Header, Form, dataExpression
=> 컴포넌트 파일 안에서 3가지 폴더를 생성하고 위의 컴포넌트를 생성하고 APP.JS에서 import해서 사용한다.


3. 이벤트 처리하기
이벤트를 복합적으로 처리하기 위해 JSX 표현식에 화살표 함수를 사용한다.
ex) onChange = {(event)=>{inputHandler()}} => 이벤트가 발생하면 해당 JSX 표현식내의 함수가 실행되고 안쪽 함수도 실행된다. 이 떄 EVENT 객체를 활용하고 코드를 분리하기 위해 위의 방법을 사용하는 것이다.


4. 상태 관리하기
=> form 컴포넌트에서 state 관리를 해서 값을 제출하거나 입력값을 reset시킬 수 있다.

객체를 가져와서 ... 스프레드 연산자로 뿌려주고 다음 라인에서 같은 키를 사용하면 오버라이딩 된다.
인자로 받은 값을 키로 사용하고 싶다면 [key] : value로 사용하면 된다. [] => 객체에 키를 넣을 떄 동적으로 넣을 수 있다. 표현식을 넣거나 변수를 넣어도 된다.

reset를 위해서 setFunc()으로 초기값을 넣어주는 핸들러
userInput의 값을 받기 위해서 이전의 값들과 업데이트 한 값을 처리하는 prevState 콜백을 이용하는 핸들러
양방향 바인딩을 위해서 value 값을 userInput의 ['']값을 준다. 새로고침하면 이전 값으로 자동으로 간다.



5. 상태 올리기

5-1. App.js 컴포넌트에 상태를 올리기 위해서 app.js에서 func를 생성하고 props로 내려주고 데이터를 제출할 떄 내려준 함수를 실행하여 app.js에 데이터를 보낸다.

5-2. App.js에서 해당 데이터를 받는다. (함수의 매개변수로 받을 수 있다.) => 이 후 그 데이터를 state로 관리한다.

5-3. 만약 데이터가 변동되지 않은 채 온다면 app.js의 계산 로직이 작동할 필요가 없기 때문에 if check를 통해 데이터가 들어온 경우만 처리하도록 한다.


6. 조건에 따라 결과 출력하기

6-1. 하위 컴포넌트에서 상태 올리기를 통해 가져온 데이터를 데이터 표시 컴포넌트에 props로 내려준다.

6-2. 데이터를 표현할 JSX에서 JSX 표현식 내의 배열 map 메서드를 통해서 동적으로 표현한다.

6-3. Intl.NumberFormat 객체를 이용해서 표현된 JSX를 포맷한다.


7. CSS 모듈 추가하기

인라인 스타일 => <p style={{....}}></p>
=> style이란 props가 객체를 통해 CSS에 영향을 줄 수 있다.


8. 두 번쨰 Demo And 사용자 컴포넌트 추가하기
label의 속성으로 for은 사용할 수 없다. htmlfor로 사용해야 한다.
label의 for 속성 => input의 id와 label의 for 속성이 같은 이름이라면 라벨을 눌러도 input이 반응한다.
form 태그의 label, input, button(submit)으로 구성되어 있기에 preventDefault()를 사용했다.


9. 재사용 가능한 "카드" 컴포넌트 추가하기
감싸는 래퍼 클래스를 만들고 싶다면 => props.children를 활용하면 된다.
props.children은 JSX가 아니라 JS 표현식이다. props.children은 card 컴포넌트의 여닫는 태그 사이에 있는 컨텐츠를 준다.

현재 감싸는 래퍼 클래스는 내장된 HTML 컴포넌트가 아니다. 사용자 정의 컴포넌트이기 때문에 그 컴포넌트 안에서 사용하는 props를 통해서만 작동할 수 있다.

=> <Card></Card>처럼 감싸는 래퍼 클래스에 속성, Class, id를 주게 되면 적용되지 않는다.
=> 속성을 주고 싶다면 래퍼 클래스 자체에 주어야 한다.
=> Card 사용자 지정 래퍼 컴포넌트에 className을 할당하고 해당 컴포넌트에 가서 props.className를 통해 구현한다.
=> 래퍼 컴포넌트의 props에는 감싼 컴포넌트들의 정보가 담겨있기 때문이다.


10. 재사용 가능한 "Button" 컴포넌트 추가하기

button의 type
1. button => 해당 버튼이 클릭할 수 있는 버튼임을 명시한다.
2. submit => 해당 버튼이 폼 데이터를 제출하는 제출 버튼임을 명시한다.
3. reset => 해당 버튼이 폼 데이터를 초기값으로 리셋하는 리셋 버튼임을 명시한다.

props로 들어오는 데이터는 감싼 요소들의 속성과 데이터들이다.


11. 사용자 입력 State 관리하기

input의 입력된 값을 JS로 불러오려면 input.value에 접근해야 한다.
=> event.target(input).value => input에 적은 값
input의 변경 사항을 트리거하여 setFunc()과 연관되어 사용될 수 있는 이벤트 onChange


12. 검증 추가 및 로직 재설정하기
input의 value값을 useState의 첫 배열값을 주게 되면 setFunc('')를 통해 변경된 값이 적용된다.
setFunc()만 사용하는 경우는 화면에는 적용되지 않는다. 뒷단의 로직은 setFunc()이 작동하지만..


13. 검증 추가 및 로직 재설정하기
input의 value는 초기값이다. => setFunc()를 실시한 다음 value 속성의 초기값이 되는 것이다.


14. 사용자 목록 컴포넌트 추가하기
props로 전달받은 값을 동적으로 JSX HTML로 보여주는 것은 map, filter를 사용하는 것이다. => 이는 규칙이다.
또한 input으로 전달받은 데이터는 해당 컴포넌트에서 바로 사용되는 경우가 거의 없기에 데이터를 끌어올려야 한다.


15. State를 통해 사용자 목록 관리하기
=> on으로 시작하는 속성은 이벤트의 key로 사용하는 것이 관례이다.
=> input 컴포넌트에서 form 속성의 button을 누르면 상위 컴포넌트에서 내려준 함수를 발동시킨다.
유효성 검사 => 내려준 함수 실행 => 초기값으로 전환 로직이 담겨있다.
=> 받은 데이터를 렌더링 컴포넌트에 내려주고 map를 사용하여 동적 렌더링한다.


16. ErrorModal 컴포넌트 추가하기
Modal를 사용해서 error를 처리하자.


17. 오류 State 관리하기





















































