1. Add form input
form 태그안에서 label, input, button를 설정하고 css를 설정하여 app.js에서 사용한다.


2. Receiving user input
input의 onChange 속성은 input의 무엇가를 적을 때마다 이벤트 핸들러가 트리거된다.
=> 이 때 이벤트 핸들러의 매개변수에 event라는 객체가 주어진다.
=> event.target은 해당 이벤트가 발생하는 곳을 물어보는 것이다.
=> event.target(input).value => 인풋태그에 적힌 값을 반환한다.
input의 값을 받을 때는 해당 DOM의 value 속성에 접근해야 한다.


3. Using multiple states
여러개의 인풋값을 어딘가에 저장해서 폼이 제출될 떄 그 값을 활용하고 싶다.
1. 함수가 재실행되어도 해당 input 값이 유지되도록 하는 방법은 useState를 사용한다.
2. 컴포넌트가 재평가되어도 값이 남아 있도록 하기 위해서 useState를 사용한다.
input의 onChange를 통해 해당 event.target.value를 받아서 setFunc()의 인자에 넣는다.
=> 이렇게 되면 상태에 저장되는 것이다.
=> 이렇게 하는 것은 컴포넌트를 업데이트하기 위해서는 아니고 변수에 저장하기 위한 것이다.
=> 이런 방식은 컴포넌트가 얼마나 많이 재평가되어도 상태는 저장되는 그대로 남게 된다.

같은 컴포넌트 안에 있는 모든 상태는 서로 완전히 구분된다.
=> 컴포넌트 안에 여러개의 state가 존재할 수 있다.

* input의 value를 반환할 떄는 언제나 String으로 받는다.

* setFunc()를 사용한다는 것은 초기값을 최신값으로 할당하는 것이 아니라 최신값을 반환하여 그 값을 사용하는 것이다.
* setFunc()는 변경된 데이터를 갖고 있다.


4. 대신 상태 하나 사용하기
여러개의 useState를 하나의 상태로 해결할 수 있다.
useState의 인자에 객체를 주면된다. useState({}); => 상태를 묶을 수 있다.
=> 이렇게 되면 상태를 업데이트 할 떄 모두를 업데이트가 된다.

* 자바스크립트 객체의 프로퍼티는 자동으로 오버라이딩이 된다.
=> let a = {person : 'HWT', age = 30}, let b = {...a, person : 'Coutinew'}
=> 위의 방식처럼 사용해도 오버라이딩이 된다.

위와 같은 값을 복사하기 위해 이전 상태를 고려할 경우 상태를 업데이트하는 방식이 문제가 될 수 있다.


5. 이전 상태에 의존하는 상태 업데이트하기
여러 상태를 하나의 객체로 만들어놓고 업데이트하는 것은 오류를 일으킬 수 있다.

상태를 업데이트 할 떄 그리고 이 떄 이전 상태에 의존할 경우 setFunc(callback)를 사용해야 한다.
setFunc의 콜백함수는 리액트가 자동으로 실행시킨다. 그리고 콜백함수는 이전 상태 스냅샷를 가진다.
이전 상태를 가진 콜백함수는 해당 함수 안에서 새 상태 스냅샷를 리턴하면 된다.

=> 다수의 상태 업데이트를 동시에 예약할 경우 오래되었거나 잘못된 상태 스냅샷에 의존하게 될 수 도 있다.
=> 4를 사용한다면 말이다.
=> 5를 사용하면 prevState 스냅샷이 항상 최신 상태 스냅샷이 되도록 보장해준다. 예약된 모든 상태 업데이트를 기억하면서





































