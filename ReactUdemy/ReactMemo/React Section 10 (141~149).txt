1. JSX 제한 사항 및 해결 방법

JSX 제한 사항
1-1. JSX 루트 요소는 1개여야 한다.
=> return 값은 하나여야 하기 때문이다.
=> JSX 코드는 리액트 createElement로 변환된다. 이 단 하나의 React.createElement 호출만 반환되어야 한다.

1-1의 문제 해결을 위해서 인접한 요소들을 div로 감싸면 쉽게 해결된다. => 이러면 하나만 반환된다. (div가 아닌 다른 element도 상관없다.)

리액트는 JSX 요소인 배열을 다루는 법을 알고 있다. 그렇기 떄문에 return JSX에서도 배열을 반환할 수 있다.
=> 이렇게 return 하면 모든 요소에 대한 키를 필요로 한다.
=> 그러나 이런 방식은 취하지 않는다. 키와 배열로 감싸는 작업이 div를 넣는 것보다 비효율적이다.

위의 방식대로 div를 하나의 루트 요소를 만들기 위한 래핑 요소로 사용했다면 실제 DOM에 많은 div가 렌더링된다.
=> 이렇게 되면 스타일링의 오류, 불필요한 요소 추가로 인한 어플리케이션 성능저하로 이어질 수 있다.


2. 컴포넌트 Wrapper 만들기
wrapper.js 컴포넌트를 만들고 return 값으로 props.children를 작성한다.
이 컴포넌트를 루트 요소로 사용한다. => 잘 동작한다.
=> 이 떄 props.children만 return 하기 때문에 div 같은 요소가 없다.
=> 요구 사항도 충족한다. 하나의 root 요소로 둘러싸져 있기 때문이다.

*** 불필요한 요소 추가도 없고 스타일링의 오류도 적어진다.


3. React Fragment
2의 래퍼 컴포넌트는 React가 이미 제공하고 있다.
=> React.Fragment or <>...</> 이 구 구문은 빈 Wrapper를 렌더링한다. (<>...</> 해당 구문을 지원하는 빌드 프로세스가 있어야 되고 React.Fragment는 항상 지원된다.)


4. 리액트 포털 소개
모달은 전체 페이지에 대한 오버레이이다. 만약 모달이 다른 HTML 코드 안에 중첩되어 있다면 CSS 덕분에 작동할지 몰라도 좋은 구조가 아니다.
=> 올바르지 않은 곳에서 사용되는 것이다.

하나의 루트 요소안에 모달과 form이 존재한다. => 스타일 덕분에 모달이 작동한다.
하나의 요소에 모달과 form이 존재하지 않고 독립적으로 존재한다. => React 포탈사용


5. 포털로 작업하기
현재 Modal이 렌더링 되는 공간은 하나의 루트 요소안에서 <div><Modal><Form><div> 형식이다. 이를 하나의 루트요소에 두지 않고 완전히 독립적인 공간에 두는 것이다. => 구조상 완벽하게

포탈은 두 가지가 필요하다. 하나는 컴포넌트를 이동시킬 장소가 필요하고 다른 하나는 컴포넌트에게 그 곳에 포털을 가져야 한다고 알려줘야 한다.

ReactDOM.createPortal(1,2)
1 => 렌더링되어야 하는 리액트 노드
2 => 1의 요소가 렌더링되어야 하는 실제 DOM의 컨테이너를 가리키는 포인터이다.
=> 렌더링할 HTML 요소를 다른 장소로 이동시키는 것이다.

=> 만약 ErrorModal이 호출된다면 (상위 컴포넌트로부터 호출) props가 존재한다. 그 props를 portal 대상 컴포넌트에 넘겨준다. 해당 포탈 컴포넌트는 이 props를 받고 protal로 가서 렌더링된다.


6. ref로 작업하기


















































