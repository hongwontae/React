1. 리액트는 어떻게 DOM을 업데이트하는가?
리액트는 index.html의 <div id="root"></div>를 매개로 삼아 렌더링된다.
=> main.jsx가 root라는 아이디를 가져오고 그 안에 APP 컴포넌트가 렌더링되어야 한다고 설정한다.

이후 렌더링되면 함수들을 등록하고 return JSX를 반환한다. 이 떄 순차적으로 반환한다.

ex)  
<app>
return
<Headers>
<Counter>
=> Headers 컴포넌트의 상태나 함수를 전부 등록하고 Headers 컴포넌트의 JSX를 전부 실행다음에 Counter 컴포넌트로 간다.


2. 리액트 리렌더링 조건
2-1. state 변경(state가 변경되어서 전달해준 props가 변경된다.)
2-2. 부모 컴포넌트 리렌더링=> 자식 컴포넌트 리렌더링


3. 개발자도구 - Profiler - o 누르고 리렌더링을 일으키면 어떤 컴포넌트가 리렌더링의 대상이 되는지, 그 이유는 무엇인지를 알 수 있다.


4. memo
memo는 컴포넌트 함수의 불필요한 실행을 막아주는 함수이다.
memo()의 인자에 컴포넌트 함수의 값을 넣으면 실행된다.
=> 부모의 컴포넌트로 인해 리렌더링의 대상이 되었을 떄, 부모로 받은 props의 값과 현재 props의 값이 같다면 재평가의 대상이 되지 않는다.

*** 모든 컴포넌트 함수를 memo로 덮는 것은 오히려 성능 저하
*** 렌더링이 필요할 떄 방해될 수 있다.


5. useCallback
컴포넌트가 재평가되면 함수들도 재평가된다. => 함수의 재평가는 새로운 메모리를 확보한다는 것이고, 변경됐음을 의미한다.
=> 이러한 효과는 의존성 배열이나 props로 전달되면 원치 않는 효과를 일으킬 수 있다.

useCallback은 의존성 배열의 변화에 의해서만 함수가 재생성되고 의존성 배열이 비워져 있다면 한 번만 생성되고 재생성하지 않는 로직을 갖고 있다.


6. useMemo
useMemo는 컴포넌트 함수 안에 있는 일반 함수들을 감싸고 그들의 실행을 방지한다.
무분별한 함수 실행을 방지하는 리액트 훅이다. => memo와 useCallback은 재생성 방지에 초점이 있다.

const a = isSet(value);
=> isSet(value) 함수는 컴포넌트가 재평가될 때마다 실행된다.
=> value은 5번 클릭에 값이 한 번 바뀐다고 가정했을 떄 함수를 지속적으로 실행하는 행위는 불필요하다.
=> const a = useMemo(()=>isSet(value), [value])
=> 의존성 배열이 변할 떄마다 함수가 실행된다.
=> 내부 로직은 익명함수의 값을 uesMemo+할당할 변수가 가지고 있는다. 의존성 배열이 변하지 않으면 리액트가 함수를 실행시키지 않는다. 의존성 배열이 변화하면 익명함수가 실행되고 useMemo와 변수가 가지고 있는다.


7.  리액트 가상 DOM 사용
컴포넌트 함수가 재실행되어도 해당 컴포넌트의 JSX가 DOM으로 재삽입되지 않는다.
=> 컴포넌트 함수가 재실행되었을 떄 JSX 반환이 이전과 다른 DOM만 재삽입된다.

위의 동작은 Virtual DOM를 통해 이루어진다.
리액트는 컴포넌트 트리를 생성하고 마지막에 렌더링되어야 하는 실제 HTML 코드를 컴포넌트 트리로부터 전달한다. 그리고 가상 DOM 스냅샷을 생성한다. 그리고 마지막 가상 DOM 스냅샷과 비교한다.

컴포넌트 트리를 만들고 이를 토대로 가상 DOM를 생성한다. 이 후 가장 최근의 DOM과 비교하여 변동사항을 파악 후 변동사항만 change한다. => 효율적으로 DOM 업데이트


8. State
상태는 컴포넌트 안에 속해 있기 떄문에 재사용이 가능하다.

키는 리액트에서 상태를 구체적인 컴포넌트 인스턴스에 매핑할 떄 고려되는 다른 요소이다.












*** import를 통해 가져온 파일의 데이터는 컴포넌트 재평가로 인해 변경되지 않는다.
*** memo를 통해 부모의 리렌더링이 트리거되어 자식 컴포넌트가 리렌더링될 떄 전달해준 props의 변경이 없다면 유지된다.
     => but 함수는 재생성되면 언제나 새로운 메모리 객체이다. 원시값과 다르다. => 이 떄 useCallback를 사용해서 함수 메모	  리를 값을 유지시켜 주는 것이다. 




































