1. 동적 세그먼트와 충돌되는 path는 구체적인 path가 우위에 있다.
ex) /product/:productId vs /product/new
=> new라는 path도 :/productId에 해당하지만 리액트 라우터는 /product/new path 라우터를 우선시한다. => 구체적인 것을 우선시한다.

(children이 구현되면 부모의 path가 자식의 path의 포함되어야 하고 부모 컴포넌트에 Outlet이 포함되어야 한다.)
(index:true => 부모 라우트의 path와 자식 라우트의 path가 일치해서 같이 보여준다는 것)


2. loader() 데이터 가져오기

loader 
=> 라우터를 정의하는 객체의 키이다. 값으로 함수를 받는다.
=> 해당 라우터를 방문하기 직전에 리액트 라우터는 loader 함수를 실행한다.
=> loader 함수를 통해 데이터를 로딩하고 가져올 수 있다.
=> 함수의 return 값은 해당 객체의 element가 얻을 수 있다.


3. loader() 데이터 사용
loader 메서드를 실행한 결과물을 element가 가져오기 위해 useLoaderData을 import한다.
const data = useLoaderData(); => 가장 가까운 loader return 값을 가져온다.
<Component events={data}/> => 데이터를 props로 넘겨준다.


4. loader() 데이터의 다양한 활용법
loader 함수를 정의하고 useLoaderData를 사용해서 데이터를 얻을 수 있다.
=> 그렇다면 모든 라우터에 데이터을 얻을 수 있는가?

=> 상위 레벨의 라우터는 하위 레벨의 라우터의 loader에 접근할 수 없다.
=> 같은 레벨이나 하위 레벨은 loader에 접근할 수 있다.


5. loader() 코드를 저장하는 위치
라우터를 정의하는 객체가 loader 키를 갖고 있지만 데이터를 가져오는 로직을 구성하다보면 난잡한 코드가 된다.
=> 해결하기 위해 loader가 사용되는 컴포넌트에 export async function loader(){...}를 구성하고 import 해서 사용한다.
=> 위의 방식은 권장되는 방식이다.


6. loader() 함수가 실행되는 시기
path의 컴포넌트가 실행되기 전에 loader()가 실행된다.

라우터 트리거 => loader() => loader()의 데이터로 component Rendering

=> backend node.js에서 get data를 1.5초 지연시킨다. => loader()가 트리거 되는 라우트를 트리거한다. => loader()가 1.5초 뒤에 데이터를 얻기 때문에 전 페이지에 1.5초 머물고 => 1.5초 끝나면 트리거 되는 라우터에서 data를 가지고 렌더링한다.


7. loader() 데이터 확인
loader가 트리거 되는 라우트 이전의 라우트에서 loader()가 어떤 상태를 지니고 있는지 확인할 수 있다.
const navigation = useNavigation();
navigation.state => 세 가지 문자열을 가지고 있다. 'loading' => 데이터를 기다리고 있음


8. loader() 데이터 반환
useLoaderData() => new Response()로 만든 데이터를 받을 수 있다.
fetch를 통해 얻는 데이터는 Promise이다. => Response??
=> anyway 별다른 조치하지 않고 바로 보내서 사용할 수 있다. useLoaderData()의 기능 덕분에

























