1. 자바스크립트 파일 내에서의 HTML => JSX라고 한다.
React의 컴포넌트는 함수이고 JSX를 리턴 값으로 화면을 렌더링한다.
컴포넌트는 HTML+CSS+JAVASCRIPT의 조합이다.
컴포넌트는 재사용이 가능하고, 코드가 연관되어 있고, 기능이 분리되어 있다.


2. 사용자 지정 컴포넌트는 두 개의 태그를 쓰지 않고 /로 끝나는 태그 하나만 써도 적용된다.
현재 컴포넌트 파일의 확장자는 jsx이다. 이는 빌드 프로세스가 jsx를 읽어서 브라우저 친화적인 코드로 변환시켜 화면에 렌더링된다. => 브라우저는 순수 react 프로젝트를 읽고 실행시킬 수 없다.

리액트에서 컴포넌트로 인식되기 위해 함수의 변수명이 대문자로 시작하고 함수에서 렌더링 가능한 값이 반환되어야 한다.
=> return 되는 JSX는 화면에 보여줘야 하는 내용이어야 한다.

한 파일 안에서 두 개의 이상의 컴포넌트를 생성하여 사용할 수 있다.


3. 처음으로 렌더링되는 페이지는 index.html이다. index.jsx에서 index.html의 root div를 선택해서 그 공간에 모든 리액트 컴포넌트가 렌더링 되도록 유도한다.
커스텀 컴포넌트는 React가 분석하고 사용되어 일반 html이 렌더링된다 .
리액트에게 혼선을 주지 않기 위해 커스텀 컴포넌트는 대문자로 시작하는 카멜케이스를 지켜줘야 한다. 일반 html 태그들은 소문자이다.

로딩된 파일 소스를 보면 리액트에서 렌더링한 html는 존재하지 않고 root div과 script 하나가 존재한다.
=> 하나의 script 파일이 작성한 리액트 코드이다. 여기서 변환된 것이다. 최종적으로는 index.html 하나가 제공된 것이다.

일반적인 html은 리액트에서 DOM 노드로서 렌더링되고 커스텀 컴포넌트는 리액트에서 함수로서 실행된다.


4. JSX 표현식
=> {} 자바스크립트 표현식을 넣을 수 있다. 값이 도출되는 식을 넣을 수 있다는 것이다.
=> 변수나 삼항 연산자, or, and...


5. 배포 과정에서 모든 코드가 변환되고 최적화되는데 이미지를 불러올 떄 img 태그를 이용해서 string으로 사진을 가져오면 최적화 과정에서 이미지가 깨지거나 유실될 수 있다. => 이를 해결하기 위해서 import를 통해 사진을 js 변수에 담고 이를 img의 src에 중괄호 표기법을 사용해서 넣어준다.


6. props => 리액트에서 데이터를 전달하는 특별한 방식이다
props를 통해 숫자를 보낼 때는 중괄호 표기법를 사용해서 보내야 한다. 그렇지 않으면 문자열로 인식한다.
props는 부모 컴포넌트가 자식 컴포넌트에게 내려주는 데이터이다. 커스텀 컴포넌트에서 key=value로 전달해준다.
자식 컴포넌트는 props.key를 통해 value를 사용할 수 있다./ 숫자 데이터를 보낼 떄는 JSX 표현식을 통해서 전달해야 한다.


7. props를 내려줄 떄 key=value가 아닌 {...데이터}를 통해 내보내줄 수 있다.
=> props = {title:..., img :....} => 데이터 형식
props로 받는 것이 아니라 객체의 키 값을 통해 구조분해할당으로 자식 컴포넌트에서 받을 수 있다.


8. jsx 확장자를 사용해서 컴포넌트를 구축할 떄는 import 문에 jsx 확장자를 적어줘야 한다.


9. React 프로세스는 css를 자동적으로 받지 않는다. import 'css PATH'를 적어야 한다. 이 떄 import 한 컴포넌트에 css가 국한되는 것은 아니다. 


10. <menu> 태그 => html 태그이다. 버튼 목록을 만드는데 사용된다.
커스텀 컴포넌트 사이의 내용은 렌더링되지 않는다. => 렌더링할 위치 불명확하다.
props.children은 컴포넌트 사이의 내용을 가져온다. => props.children를 사용하는 컴포넌트에서 해당 텍스트나, 속성 등을 가져와서 사용한다. 

컴포넌트 사이의 내용을 사용하는 것을 컴포넌트 합성이라고 부른다.


11. HTML 요소들은 DOM으로 생성될 떄 JS와 상호작용할 수 있는 프로퍼티가 생성된다. => 이 프로퍼티들 중 onClick과 같은 트리거 속성이 존재한다. 
React는 onClick={func}으로 작동한다.


12. 함수 또한 props를 통해 전달할 수 있다. props.children 같은 속성은 이름을 임의적으로 바꾸거나 삭제할 수 없다.


13. jsx 표현식은 함수가 들어갈 수 있다. => 화살표 함수 자체가 들어갈 수 있다. => 이를 통해서 정확한 매개변수를 통제할 수 있다. (이벤트로부터 독립적인 함수)


14. 리액트 컴포넌트는 한 번 평가되고 렌더링되면 일반적인 방법으로는 재평가하지 않는다. 일반 JS 코드로 DOM를 변경한다해도 변경된 값을 얻지 못해 기존의 값만 보인다. => 재평가를 위한 상태 코드가 필요하다.


15. useState는 상태를 관리하는 react Hooks이다. react Hooks는 최상단 레벨에서 사용되어야 하고, 컴포넌트 함수 내에서 사용되어야 한다.
(setFunc()의 효과를 받는 컴포넌트가 재평가의 시작부분이다.)
(부모 컴포넌트에서 실행되는 곳과 자식 컴포넌트에서 실행되는 코드의 차이를 식별해야 한다.)

useState의 반환값은 배열이라 배열구조분해를 사용해서 초기값과 setFunc를 받는다.
=> setFunc은 초기값을 변경시키기위해 리액트에게 재평가를 명령하는 함수이다.


16. High state Change
1. 이벤트 핸들러 자체에 함수 포인터가 아닌 화살표 함수를 적용한다. => 원하는 매개변수를 사용할 수 있다.
2. 해당 매개변수는 jsx 표현식에서 동적 배열 표현으로 들어간다.
3. setFunc으로 동적 배열 표현이 변경되면 표현하는 data가 변경되어 원하는 코드를 작성할 수 있다.


17. 동적인 반환을 위해서 3가지 방법이 존재한다. 삼항 연산자, and/or 연산자, JSX 표현식 변수 할당


18. react에서는 class는 className으로 사용해야 한다. className를 할당할 떄 JSX 표현식를 사용해서 동적으로 표현할 수 있다. props를 통해 true나 false를 전달해서 선택된 버튼만 css를 적용하는 방법이 존재한다.


19. map이나 filter를 통해 동적으로 JSX를 표현할 수 있다. 다만 return이 없으면 안된다.
data로 받아온 값을 props로 넘기던지, 일반적으로 표현할 것인지는 선택이다.
=> 사용되는 데이터만큼 표현됨으로 오류 발생 가능성이 적어진다.
=> {} 안에서 사용되어야 한다. JS 데이터 배열을 매개로 많이 사용된다.
 
































