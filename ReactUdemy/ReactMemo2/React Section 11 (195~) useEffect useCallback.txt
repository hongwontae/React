1. sied Effect(부수 효과)란?
웹 동작하기 위한 기능이지만 컴포넌트 렌더링 과정에서 직접적인 영향을 미치지는 않는 작업을 의미한다.


2. 부수효과를 잘못사용하면 무한 루프가 될 수 있다.
(JS는 비동기 함수는 비동기 처리하고 일반함수는 동기적으로 처리한다. 콜백함수는 이들의 순서를 보장하고 제어하기 위해서 사용된다.)


3. useEffect
useEffect()는 두 가지 인수를 받는다. 하나는 콜백함수, 하나는 의존성 배열이다.
useEffect()의 기본동작은모든 JSX가 반환되었을 떄(컴포넌트 함수의 실행 후에) useEffect()의 콜백함수를 실행시킨다.

의존성 배열의 값에 따라 useEffect의 작동방식이 달라진다.
빈 배열의 경우 처음 모든 컴포넌트가 렌더링되고 나서 useEffect 콜백함수가 실행된다. 이후의 의존성 배열이 없기 때문에 다시 실행하지 않는다.

의존성 배열이 누락된 경우에는 재평가마다 실행된다. => 초기에 컴포넌트 함수 실행으로 JSX를 반환하여 DOM를 생성하고 브라우저 제공 => useEffect 콜백함수 실행 => 리렌더링 => JSX 반환 => useEffect 콜백함수 실행 =>..... 지옥이 될 수 도 있다.

**** JSX가 반환된 이후에 useEffect 콜백함수가 실행되는 것이다. 즉 재평가가 두 번되는 것이다.


4. useEffect가 필요한 경우는 무한 루프를 방지하거나 컴포넌트 함수들이 모두 반환되었을 떄 실행시켜야 하는 코드의 경우이다.

모든 부수효과가 useEffect에 들어갈 필요는 없다. => 일반 함수에 들어가는 것이 흐름상 맞는 경우 useEffect를 고려하지 않아도 된다.


5. useEffect의 또 다른 역할로써 동기화 역할이 있다. 컴포넌트가 실행될 떄 본문이 JSX의 DOM를 변경할 떄 JSX는 렌더링되지 않았기 때문에 코드가 작동하지 않는다. useEffect의 특징을 이용해서 DOM를 변경시킬 수 있다.


6.  useEffect의 CleanUp 함수 => useEffect를 구현한 컴포넌트가 DOM에서 제거될 떄 실행되는 함수이다.
useEffect의 콜백함수의 return의 익명함수가 클린 업 함수이다.
ex) useEffect(()=>{.... return ()=>{console.log(....)}},[ ])


7. 의존성 배열로 함수를 추가하게 되면 무한 루프를 생성하게 될 가능성이 높다.
useEffect의 의존성 배열로 상위 컴포넌트의 함수를 넣으면 무의미하다고 판단한다. 
=> 상위 컴포넌트의 함수는 재평가되어도 동일하다고 생각하기 때문이다.

상위 컴포넌트가 재평가되면 모든 코드가 재생성되는 것이다. => 함수 === 함수 => false
(함수 또한 객체이다. 객체는 값이 같다 해도 동일한 값은 아니다. 

의존성 배열에 함수는 지속적으로 바뀌기 떄문에 무한 루프에 걸린다.


8. 7의 문제점을 개선하기 위해 useCallback 훅이 있다. useCallback의 값을 변수에 등록하면 그 함수는 재평가 시 함수가 다시 읽어지고 다시 등록되지 않는다. useCallback의 함수는 메모리 상에 등록되어서 필요할 떄마다 쓰여진다.
그리고 두 번쨰 인자로 의존성 배열을 받는다. 해당 의존성 배열이 바뀔 떄마다 다시 함수가 재평가된다.



Core Concepts

1. useEffet
useEffect는 mount, unMount, update시에 특정 작업을 실행시키는 Hook이다.
1-1. useEffect((   )=>{console.log('Mount시에만 작동한다.')  }, [  ])
=> 컴포넌트가 렌더링이 완료되고 한 번만 특정 작업을 실행시키려면 빈 배열을 위치시키면 된다.
=> 만약 2 번쨰 인자를 생략했을 떄는 리렌더링이 될 떄마다 트리거되어 effect 함수가 실행된다. => 무한 루프 가능성

1-2. useEffect(()=>{'Update 시에 실행된다.'}, [dependency])
=> 특정값이 업데이트 되고 나서 실행시키려면 의존성 배열을 추가하면 된다.
=> 이 떄 Mount 시에도 실행되기 떄문에 로직 구성할 떄 알아둬야 한다.
=> useRef를 통해 update 시에만 effect 함수를 트리거 할 수 있다.

1-3. useEffect(()=>{.... return ()=>{ console.log('Clean Up') }} , [])
=> 컴포넌트가 언마운트 될 떄(DOM에서 제거될 떄) 작업을 실행시키려면 return에 익명함수를 사용하면 된다.

1-4. useEffect(() => {console.log(data) return ()=>{console.log(change)}}, [data]);
=> 의존성 배열의 데이터가 update되면 useEffect의 콜백 함수가 실행되기 전에 cleanUp 함수가 실행된다.
*** 의존성 배열 변화 감지 => CleanUp 함수 실행 => useEffect 본문 함수 실행 


2. useCallback
























