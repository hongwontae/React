1. React Project에서 정적인 데이터들은 Index.html에 적용시켜도 된다.


2. public 폴더의 파일들은 React 개발 서버 및 빌드 프로세스에 의해 공개적으로 제공된다. => index.html, index.css에서 직접 참조(사진 이름만 기입)할 수  있다. 이는 브라우저에서 직접 방문도 가능하다.
(public 폴더 또한 React 파일에서 접근이 가능하다. => 빌드 프로세스에서 최적화 x)

src/assets은 공개적으로 제공되지 않는다. => 직접 참조x(경로/파일명.확장자) React 파일에서 사용되고 불려진 파일은 빌드 프로세스에 의해 최적화되고 브라우저에 제공되기 전에 public/ 폴더에 삽입된다.

정적으로써 index.html에 사용될 파일은 public/ React.jsx에서 사용될 파일은 assets


3. input tag의 required는 form 내의 input 태그에 아무것도 없이 서버에 전송되면 오류를 내보낸다.


4. 리액트는 컴포넌트를 사용할 때마다 새로운 인스턴스를 생성한다. (<Player/>) 이 인스턴스들은 각자의 스코프를 가지고 있다. 컴포넌트 인스턴스들은 상호작용하지 않는다.


5. true와 false를 뒤집는 로직은 ! or 삼항연산자이다.(isEditing ? false : true)


6. 리액트는 상태를 batch처리한다. (모아서 처리한다. 렌더링이 많이 일어나면 성능이 하락한다.)
다만 setFunc((prevState)=>{return ...})은 가장 최신값을 기반으로 처리하기 때문에 바로 처리한다.
=> 항상 setFunc()를 예정된 변경사항이 실행되어서 값이 변경된 최신의 값만 가져온다.
=> 이것이 가능한 이유는 setFunc(()=>{})은 예정된 사항 이후에 실행되기 떄문이다.

setFunc() 자체는 상태값을 바로 변경하는 것이 아니라 예약한다. => setFunc()이 두 번 호출되면 상태값이 두 번 바뀌어 유지되는 것이 아니라는 뜻이다.


7. 양방향 바인딩 => input의 value를 가지고 와서 입력값을 컴포넌트에 상태 변경 값으로 지정하여 리렌더링한다.
input의 value는 입력값을 의미한다. onChange는 키보드 입력할 때 트리거되는 이벤트이다.


8. 다차원 리스트 렌더링
=> 다중 배열을 동적으로 렌더링하는데 map을 두 번사용해서 렌더링한다.


9. setFunc()은 batch 처리돼서 (다른 setFunc를 기다린다.) 이벤트 핸들러 안에서 여러 번 호출해도 한 번만 호출되는 결과값을 낳는다.
setFunc(callBack)은 이전 값에 기대어 업데이트 하기에 두 번 사용하면 원하는 기대값이 나온다. => setFunc()이 batch 처리되고 업데이트 되어 새 값이 나오면 그 값을 가져간다.

initialValue가 배열이나 객체의 경우 참조값을 바로 수정시키는 것은 오류를 발생시킨다. => 상태 업데이트 흐름에 벗어나기 때문이다. 리렌더링은 react가 값의 변경사항을 인식했을 경우 변경되는데 업데이트 스케줄 전에 initialValue가 변경된다면 값의 변경을 알 수 없기 때문이다. (원시값은 기본적으로 불변하다.) => 참조값을 그대로 박아서 사용하면 안된다.


10. 함수의 호출 순서는 이벤트가 트리거되는 컴포넌트가 시작이다./ 상태 올리기를 사용하면(해당 함수를 호출하면) 해당 함수를 작성한 컴포넌트가 재평가의 시작점이 된다.

setFunc()의 batch 단위는 이벤트 핸들러이다.


11. 같은 상태값을 사용한다면 useState를 두 개 만들어서 사용할 필요가 없다.
상태 끌어올리기란 함수를 자식 컴포넌트에게 props로 내려주고 자식 컴포넌트에서 속성이 호출되었을 떄 해당 값의 처리는 부모 컴포넌트에서 행하는 것이다. => 일괄적으로 처리하거나 다른 컴포넌트에게 내려주기 쉽게 하기 위해서


12. Log 컴포넌트에게 줄 데이터 gameTurns는 객체를 채운 배열이며 플레이어가 어떤 버튼을 눌렀는지 대한 정보, 각 버튼 위치이다. (모양에 의거하여 플레이어를 식별한다.)
useState에 의거한 setFunc를 사용할 떄 다른 상태의 값을 가져와 사용하는 것은 이상적이지 않다. => 그 상태값에 대한 정보가 신뢰되지 않기 때문이다.

*** 상태의 값을 변경하기 위해 객체나 배열을 기반으로 한 상태값은 직접 건드리지 않고 복사하여 return 한다.
      상태를 merge 시키면 신뢰할 수 없다. => 버그 가능성이 높아진다. 다른 로직을 구성한다.


13. 제어하는 상태의 수는 최소화, 각 상태에서 많은 값을 파생시키는 것 => 리액트를 다루는 효율적인 기법이다.
setFunc() 리턴 값을 제어하기 위해서 이벤트 핸들러에 매개변수가 필요한 경우 함수 포인터를 가리키는 것이 아닌 화살표 함수를 작성한다.


14. 동적 컴포넌트를 구현할 떄 key 값은 유일하면 된다./ 현재 애플리케이션의 구조는 app에 상태를 끌어올린다음 한꺼번에 내려주는 전략이다.


15. button disabled 속성이 존재한다. 자동으로 true를 가지고 있고 true라면 버튼을 클릭하지 못한다.
=> JSX 표현식을 통해 동적으로 disabled를 제어할 수 있다.


16. export 변수명 = [....] => import {변수명} from 'path' => export 변수명을 다른 파일에서 import해서 사용


17. spread 연산자를 사용하면 값만 가져오고 얕은 복사를 한다. => 중첩 값은 참조값을 따른다.

중첩배열일 떄 =>
let a = [[1,2],[3,4],[5,6]]

 let a = a1.map(data => [...data])
=> map은 배열 하나를 대상으로 반복한다. a의 0인덱스는? [1,2]이다. [...spread]를 사용하면? 중첩배열로 인식되고 참조값도 변한다.
























