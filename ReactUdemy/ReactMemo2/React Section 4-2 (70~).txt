1. React Project에서 정적인 데이터들은 Index.html에 적용시켜도 된다.


2. public 폴더의 파일들은 React 개발 서버 및 빌드 프로세스에 의해 공개적으로 제공된다. => index.html, index.css에서 직접 참조(사진 이름만 기입)할 수  있다. 이는 브라우저에서 직접 방문도 가능하다.
(public 폴더 또한 React 파일에서 접근이 가능하다. => 빌드 프로세스에서 최적화 x)

src/assets은 공개적으로 제공되지 않는다. => 직접 참조x(경로/파일명.확장자) React 파일에서 사용되고 불려진 파일은 빌드 프로세스에 의해 최적화되고 브라우저에 제공되기 전에 public/ 폴더에 삽입된다.

정적으로써 index.html에 사용될 파일은 public/ React.jsx에서 사용될 파일은 assets


3. input tag의 required는 form 내의 input 태그에 아무것도 없이 서버에 전송되면 오류를 내보낸다.


4. 리액트는 컴포넌트를 사용할 때마다 새로운 인스턴스를 생성한다. (<Player/>) 이 인스턴스들은 각자의 스코프를 가지고 있다. 컴포넌트 인스턴스들은 상호작용하지 않는다.


5. true와 false를 뒤집는 로직은 ! or 삼항연산자이다.(isEditing ? false : true)


6. 리액트는 상태를 batch처리한다. (모아서 처리한다. 렌더링이 많이 일어나면 성능이 하락한다.)
다만 setFunc((prevState)=>{return ...})은 가장 최신값을 기반으로 처리하기 때문에 바로 처리한다.
=> 항상 setFunc()를 예정된 변경사항이 실행되어서 값이 변경된 최신의 값만 가져온다.
=> 이것이 가능한 이유는 setFunc(()=>{})은 예정된 사항 이후에 실행되기 떄문이다.

setFunc() 자체는 상태값을 바로 변경하는 것이 아니라 예약한다. => setFunc()이 두 번 호출되면 상태값이 두 번 바뀌어 유지되는 것이 아니라는 뜻이다.


7. 양방향 바인딩 => input의 value를 가지고 와서 입력값을 컴포넌트에 상태 변경 값으로 지정하여 리렌더링한다.
input의 value는 입력값을 의미한다. onChange는 키보드 입력할 때 트리거되는 이벤트이다.


8. 다차원 리스트 렌더링
=> 다중 배열을 동적으로 렌더링하는데 map을 두 번사용해서 렌더링한다.


9. setFunc()은 batch 처리돼서 (다른 setFunc를 기다린다.) 이벤트 핸들러 안에서 여러 번 호출해도 한 번만 호출되는 결과값을 낳는다.
setFunc(callBack)은 이전 값에 기대어 업데이트 하기에 두 번 사용하면 원하는 기대값이 나온다. => setFunc()이 batch 처리되고 업데이트 되어 새 값이 나오면 그 값을 가져간다.

initialValue가 배열이나 객체의 경우 참조값을 바로 수정시키는 것은 오류를 발생시킨다. => 상태 업데이트 흐름에 벗어나기 때문이다. 리렌더링은 react가 값의 변경사항을 인식했을 경우 변경되는데 업데이트 스케줄 전에 initialValue가 변경된다면 값의 변경을 알 수 없기 때문이다. (원시값은 기본적으로 불변하다.) => 참조값을 그대로 박아서 사용하면 안된다.

























