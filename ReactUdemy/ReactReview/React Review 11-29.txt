1. 데이터를 표현하는 컴포넌트들은 정적으로 표현하기에는 제약이 많다.
2. 동적으로 표현하기 위해서는 Arr.map를 사용하면 된다.
3. props로 넘어온 값들은 배열임으로 arr.map((data)=><Component key={value} props={value}><Component>)

4. useState의 setFunc()를 사용할 떄 이전 값에 기대어 렌더링하는 경우에는 setFunc()의 콜백을 사용하면 안전하게 렌더링할 수 있다. setFunc((prevState)=>{}) 콜백의 매개변수에는 자동으로 이전 상태값이 존재하고 이를 이용하면 다른 상태를 신경쓰지 않고 안전하고 확실하게 이전값+업데이트할 값으로 렌더링할 수 있다.

5. keys map으로 동적으로 데이터를 표현할 떄는 각 컴포넌트들에 key를 부여해야 한다. React는 자동으로 배열의 순서를 맞추지 않는다. 업데이트가 되면 업데이트 데이터를 무조건 밑에 넣고 대상 데이터들을 전부 실행하고 배열의 순서에 맞게 렌더링한다.
=> 불필요한 렌더링 방법이다.
=> React가 인식하는 컴포넌트에 key={value}를 주어서 동적으로 변환한다.

6. 부모 컴포넌트에 리렌더링이 되면 하위 컴포넌트들도 리렌더링이 된다. 부모로부터 받은 props값이 변경되면 리렌더링이 된다. state가 변경되면 리렌더링이 된다. forceUpdate가 실행되면 리렌더링이 된다. 이 리렌더링은 컴포넌트 전체를 실행하는 것이다. 이를 기반으로 모든 업데이트하고 싶은 데이터를 setFunc()를 따로 쓰지 않고 변경할 수 있다.


7. if문이나 for문은 JSX 표현식에서 사용할 수 없다. 다만 jsx 표현식은 삼항 연산자나 and,or 할당연산자를 사용하여 컴포넌트를 동적으로 반환시킬 수 있다.
8. 변수에 JSX를 할당할 수 있다. => return jsx 위의 js코드에서 if나 for문을 사용해서 변수에 할당한 다음 그 값을 return할 수 있다.
9. 위의 조건들은 상황마다 크게 다름으로 상황에 맞춰 사용해야 한다. 대원칙은 JSX는 웬만하면 clear한 상태를 유지하자