1. useEffect()
React Hooks => 컴포넌트가 JSX를 반환한 뒤 실행되는 코드이다. 코드의 구조에 따라 다양하게 사용된다.

useEffect(()=>{....},[]) => 의존성 배열 존재x, 본문 존재 => Mount 다음에 일어나는 코드, 이후에 반응하지 않음
useEffect(()=>{....}) => 의존성 배열 자체 x, 본문 존재 => Mount 다음, 리렌더링 다음 일어나는 코드이다. => 사용x
useEffect(()=>{.....}[....]) => 의존성 배열 o, 본문 존재 => Mount 다음, 의존성 배열 변경 확인 시 실행 
useEffect(()=>{.... return ()=>{}},[]) => 의존성 배열x, 본문 존재, 클린업 함수 존재 => Mount 다음에 unMount 이전에 일어나는 코드
useEffect(()=>{.... return ()=>{}}, [.....]) => 의존성 배열 o, 본문 존재, 클린업 함수 존재 => Mount 다음에, 의존성 배열의 변화 확인 후 useEffect 함수 실행 전 클린 업 함수 발동 다음 useEffect 콜백 실행, unMount 전에 클린업


2. useCallback
컴포넌트 재평가가 일어나면 컴포넌트들의 함수들도 재평가되어 새로운 메모리 값을 갖는다. => 기존과 같은 코드지만 React는 다른 함수라고 인식한다. 성능 저하가 일어날 수 있다.
=> useCallback(func(), []) => 의존성 배열의 변화가 있을 떄만 함수를 재평가한다.


3. Memo
부모 컴포넌트가 재평가되면 자식 컴포넌트들도 재평가된다. 이 떄 props를 전달만 해주는 역할만 한다면 자식 컴포넌트 리렌더링이 성능저하로 이어진다. 
=>const Counter =  memo(function Counter({props1, props2}){...}) => 컴포넌트가 렌더링 대상이 되었을 떄 props의 값의 변동을 확인하고 변동이 있을 떄만 컴포넌트를 리렌더링한다.


4. useMemo
컴포넌트 내부에서 일반 함수 호출 시에 의존성 배열을 두고 의존성 배열의 값의 변동에만 실행시키고 싶다면 사용하는 함수이다.
const func1 = useMemo(()=>{isSet(value)}, [value])
=> 초기 실행 + value 변화만 있을 떄만 실행



















