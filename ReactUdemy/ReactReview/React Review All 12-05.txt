1. React를 로컬에 생성하는 방법 => npx create-react-app 파일명


2. 리액트의 특징

2-1. Data Flow
=> 데이터의 흐름이 단방향이다. 위에서 아래로 흐른다.

2-2. Component 기반 구조
=> UI를 만들 떄 여러 컴포넌트를 쪼개서 만든다. => 재사용성과 반복회피가 특징이다.

2-3. Virtual Dom
=> Virtual Dom은 가상의 DOM를 의미한다. 이벤트가 발생할 떄마다 Virtual Dom를 생성하고 다시 렌더링할 떄마다 실제 DOM과 비교하고 전후 상태를 비교해, 변경이 필요한 최소한의 변경사항만 실제 DOM에 반영해, 앱의 효율성과 속도를 개선할 수 있다.

2-4. Props and State
props => 부모가 자식에게 내려주는 읽기 전용 데이터를 의미한다.
state => State는 데이터를 의미하고 코드에 따라 동적으로 값이 변경된다. 각각의 state는 독립적이다.

2-5. JSX
=> JavaScript를 확장한 문법이다.

2-6. 리액트 서버
리액트 프로젝트를 생성하면 앱에는 웹 서버가 내장되어 있다.


** localhost 
=> 내 컴퓨터 주소를 가르킨다. localhost의 요청은 자신의 컴퓨터에 전달된다. : 뒤에 번호는 포트이다. 포트 번호는 컴퓨터에서 실행되고 있는 서버를 구분하는 번호이다.


3. 컴포넌트란?
HTML+CSS+JS 로직이 합쳐진 덩어리이다. 컴포넌트의 장점은 재사용성과 코드 분리이다.
컴포넌트는 JavaScript 함수이다. JSX가 리턴된다.


4. React 프로젝트 동작 원리
브라우저는 React 자체를 이해하지 못한다. npm 프로세스가 React 파일을 읽고 브라우저 친화적인 코드로 변환하여 브라우저에게 전달하는 것이다.
처음으로 실행되는 파일은 ./src/index.js이다. index.js에서 렌더링할 장소를 찾고 어떤 파일이 들어가야 하는지 결정한다. => App.js가 해당된다.
js를 제외하고 import하는 파일들은 확장자를 명시해야 한다.


5. React Component and JSX
Component는 단지 JS 함수이다. 이 함수의 리턴값은 JSX이다.
Component를 통해 사용자 지정 태그로 사용하려면 파일명과 export default 파일명을 대문자로 지정해야 한다. React 프로젝트는 html 태그를 소문자로 사용자 지정 컴포넌트는 대문자로 인식한다.
JSX는 return 할 떄 하나의 루트요소만 반환되어야 한다. => ex) div안에 모두 포함된 JSX
JSX 내에서는 동적 표현식 {}를 사용할 수 있다. {}안에서는 JS 표현식을 사용할 수 있다. 표현식 => 값이 반환되는 것을 의미한다. (함수는 return 값이 존재해야 함)


6. props
부모 컴포넌트에서 자식 컴포넌트에 내려주는 읽기 전용 데이터를 의미한다. => 자식 컴포넌트에서 props를 수정할 수 없다.

props 전달 방법
6-1. 부모 컴포넌트에서 자식 사용자 지정 컴포넌트에 속성으로 부모 데이터를 넣는다. => 넣는 값은 자유롭다. (배열 안에 객체를 넣는 경우가 많다.)
6-2. 자식 컴포넌트의 매개변수로 props를 받는다. 이떄 props = {부모 컴포넌트 속성 키 : [{name:'hwt', age:300}]};
=> 이 떄 객체구조분해를 통해 줄여서 가져올 수 있다. component = ({부모 컴포넌트 속성 키})=>{...} => 이렇게 되면 props.속성키.data가 아닌 속성키.data로 줄여서 사용할 수 있다.
6-3. 부모 컴포넌트에서 데이터를 주는 방식은 매우 유연하다. 다만 배열로 주는 경우가 접근하기 쉽기 때문에 많이 사용된다.
6-4. props로 내려올 떄는 항상 props = {} 객체 안에 담겨서 내려온다. => 그래서 객체구조분해가 가능한 것이다.


7. etc..
사용자 지정 컴포넌트는 종료태그로 하나만 사용되도 된다.


8. props.children
태그와 태그 사이의 모든 내용을 표시하기 위해 사용되는 특수한 props를 의미한다.
=> ReactConcepts에 있다.


9. props 활용
=> props는 사용자 지정 컴포넌트의 속성에 key={value}로 넣어준다.
=> 자식 컴포넌트는 이 props를 읽기만 가능하다. 변경하는 것은 불가능하다.
=> 자식 컴포넌트의 인자를 통해 읽을 수 있다. props = {key : value}


10. JSX return
과거에는 JSX를 만들기 위해 React 객체를 만들어서 사용했다. => 객체의 메서드 반환은 하나이기 때문이다.
=> 즉, 하나의 루트 요소만 반환이 가능하다.


11. 파일경로
./ => 동일한 경로
../ => 뒤 경로
=> import 경로는 현재 파일의 위치를 기준으로 작성하면 된다.


12. 컴포넌트 작성법
=> 함수 선언식이나 함수 표현식를 사용한다.

function func1(){
....
}

const func2 = ()=>{
...
}
=> 첫 글자는 대문자인 카멜케이스 방식을 사용해야 하고 export default 파일명과 함수명과 파일명은 일치해야 한다.


12. React Event
=> DOM이 만들어 질 때 각 DOM에 이벤트 수신 객체가 존재한다.
=> 이를 사용해서 onClick, onChange 등을 사용해서 이벤트를 듣고 이벤트 핸들러를 부여한다.
=> 이벤트 이름은 Handler라고 짓는 것이 관례이다.
=> 이벤트 속성은 onClick 처럼 on은 소문자 다음부터는 카멜케이스를 지켜주면 된다.


13. 리액트 렌더링 과정
부모 컴포넌트에서 사용자 지정 컴포넌트가 사용되면 위에서 아래로 컴포넌트들이 읽고 평가된다. 이 떄 JSX만 해당되는 것이 아니다. 컴포넌트 자체가 읽고 해석되어 평가된다.

만약 DOM 요소를 바꾸는 리렌더링이 필요하면 단순한 이벤트 핸들러로는 동작하지 않는다. 상태를 이용해야 한다.


14. useState()
=> const [data, setData] = useState('pizza')
=> data는 초기값이고 setData는 컴포넌트를 재평가하라는 함수이다.

=> setData()를 사용해서 컴포넌트를 재평가하여 DOM에 반영되면 모든 컴포넌트들이 재평가되는 것이 아니다. 각 컴포넌트들의 state들은 독립적이기 떄문에 리렌더링의 조건에 걸리지 않으면 해당 사용자 지정 컴포넌트만 재평가된다.


15. form button
form 태그 내에 button이 submit 속성을 갖고 있다면 form의 기본동작은 서버에 데이터를 전송하는 것이다.


16. input
input의 value 속성은 1. 초기 글자를 설정할 수 있다 2. 서버에 제출될 떄 value 속성이 전달된다.


17. 상태 위로 올리기

17-1. 상위 컴포넌트에서 하위 데이터를 끌어올리기 위한 함수를 작성한다.
17-2. 하위 컴포넌트에 해당 함수를 key={func}으로 내려준다.
17-3. 하위 컴포넌트에서 해당 함수를 사용한다.
17-4. 이렇게 되면 상위 컴포넌트에 데이터가 존재하게 되고 이를 처리할 수 있다.


18. 리렌더링 이용하기
만약 어떠한 이유에서 리렌더링이 발생하면 해당 컴포넌트 파일이 전체적으로 재평가되는 것이다.
이 특징을 이용해서 setFunc를 사용하지 않고 데이터만 변경하고 setFunc이 호출되면 재평가되는 도움을 받을 수 있다.


19. 동적으로 데이터 렌더링하기
배열이 내려왔기 때문에 {props.data.map(data)=>{<ExpenseItem></ExpenseItem>}}
이렇게 몇 개가 내려올지 모르는 상황에서 사용할 수 있다.
=> returm에 대해서 생각해야 한다. return된 객체만 렌더링된다.


20. 이전 스냅샷 state
useState를 사용할 떄 이전 데이터에 기반해서 업데이트하고 싶다면
setFunc(prevState => {
  console.log(prevState)
})
=> 이전 스냅샷에 대한 데이터가 setFunc의 콜백의 인자에 자동으로 들어가 있다.


21. 동적으로 반환할 떄 key의 중요성
map이나 filter를 사용해서 동적으로 반환할 떄 key를 부여하지 않으면 React 프로젝트는 업데이트 요소를 맨 밑에다 렌더링하고 모든 데이터를 업데이트해서 다시 렌더링하여 배열의 순서를 맞춘다. => 비효율적인 렌더링 방식이다.
key가 있다면 어디에 추가되어야 할지 React에게 알려주는 것임으로 key를 부여한다. idx를 주든가 다른 고유한 데이터를 주든가 상관없다.


22. JSX 동적 반환-2
삼항 연산자를 사용해서 동적으로 반환하거나 동적으로 CSS를 적용시킬 수 있다. {}안에는 for이나 if를 사용할 수 없지만 JSX가 아닌 일반 JS를 사용해서 for과 if를 사용해 반환시킬 수 있다.



































