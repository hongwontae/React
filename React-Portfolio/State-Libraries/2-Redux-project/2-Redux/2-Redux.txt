1. 리덕스의 작동 방식
1-1. 리덕스는 하나의 저장소를 갖고 모든 상태를 저장한다.
1-2. 컴포넌트와 저장소를 연결한다. => 구독한다라고 한다.
1-3. 컴포넌트는 저장소의 데이터를 직접적으로 조작하지 않는다.
1-4. 리듀서 함수를 통해 데이터를 조작한다. => 데이터의 업데이트를 담당한다.
1-5. 컴포넌트 => 디스패치 => 액션(수행해야할 작업) => 리듀서 함수 => 중앙 데이터 상태 변경 => 컴포넌트에게 알림
=> UI 변경


2. 리덕스 작동 방식 +
2-1. npm install redux
2-2. npm install react-redux

2-3. 리덕스 관련 파일 => store에 저장한다.
2-4. reducerFunc - store를 연결한 뒤 export로 내보낸다.
=> reducerFunc은 인자로 현재 상태와 액션을 받는다. 현재 상태에는 default 값이 부여되야 한다.

2-5. Provider react-redux 컴포넌트를 최상단 <App>에 덮는다.
2-6. store prop에 앞선 작업의 store을 불러서 넣는다.
=> 모든 컴포넌트들은 구독을 할 수 있고 액션을 날릴 수 있는 조건이 완성된다.

2-7. useSelector()를 통해 데이터 값을 가져오고 컴포넌트-저장소 구독을 할 수 있다.
=> import {useSelector} from 'react-redux';
=> const counter = useSelector((state)=>{
    return state.counter
}) => 데이터를 가져오는 훅이자 구독도 시켜주는 훅
*** 구독이 되었기 떄문에 저장소의 데이터가 변경되면 자동으로 컴포넌트가 업데이트된다.

2-8. useDispatch()의 호출을 통해서 dispatch() 함수를 얻을 수 있다. dispatch의 인자는 action이다.
=> import {useDispatch} from 'react-redux';
const dispatch = useDispatch();
function incrementHandler(){
    dispatch({type : 'increment'});
} => onClick에 붙으면 action이 트리거되어 (dispatch) 리듀서 실행되고 저장소의 데이터가 변경되고 구독된 컴포넌트들의 
반응하여 UI가 변경된다.
2-9. action은 다양하게 사용될 수 있다. {type : '..', amount :10};


2-10. reducerFunc의 리턴값은 완전 새로운 객체인 새로운 snapshot이어야 한다.
=> *** 기존의 저장소의 상태값은 객체로 저장되어 있다. 리듀서의 반환값이 이를 완전히 대체하기 떄문에 return 값에는
모든 상태값이 있어야 하는 것이다. ***
=> 이러한 방식은 기존의 state 값을 직접적으로 변경하는 것을 막기 위함이다.
=> React에 의해서 값이 변경되어 리렌더링을 야기시켜야 올바르다.

=> 객체의 프로퍼티의 접근해봤자 해당 객체의 참조값과는 관련없다.





