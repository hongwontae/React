*** 제일 중요한 것은 createContext 객체, provider의 객체의 key의 이름이 모두 동일해야 한다. ***
*** useContext를 사용하는 이유는 props drilling(props를 전달하기 번거롭기) 때문이다. ***
*** Context-API는 상태값을 공유한다. ***

*** Context API는 Provider의 상위 컴포넌트(ContextProvider는 Context.Provider를 return)
가 덮여진 컴포넌트들은 구독해서 상태를 가져올 수 있다. ***
*** Context API에서 구독이란? => useContext를 사용해서 값을 가져왔을 떄 구독된다. ***

*** 구독한 컴포넌트들 중 하나의 상태라도 변경되면 관련이 없는 컴포넌트라도 전체 구독 컴포넌트가 리렌더링된다. ***
*** 이를 피하기 위해서 ContextProvider를 여러 개 생성해서 저장소를 여러 개 만들고 쓸데없는 리렌더링을 피할 수 있게 한다. ***1

*** provider를 return하는 함수는 애플리케이션이 최초로 렌더링될 떄 실행된다. ***
=> 그렇기 떄문에 useEffect를 사용할 수 있다.


1. createContext 생성 후 variable export
2. 컨텍스트 상태를 사용할 모든 컴포넌트를 덮는다. createContext의 variable를 통해서
3. <Context.Provider value={{..}}>
4. 사용할 컴포넌트들은 useContext, variable를 통해 얻어서 사용한다.

5. <Context.Consumer>
=> <provider value>로 덮힌 컴포넌트에서 <Context.Consumer>를 사용할 수 있다.
<Context.Consumer>
{
    (ctx)=>{ // ctx => 컨텍스트 값이 담겨져 있다. 
        return(
            <>
            ....
            </>
        )
    }
}
</Context.Consumer>
=> but 가시성이 떨어지기 떄문에 Consumer보단 Provider + useContext를 더 많이 사용한다.

6. 연결된 컨텍스트 값이 변경되었을 떄 컴포넌트를 재실행한다.

7. 상태 관리 로직+함수를 한곳에 모으고 객체형식으로 상태값 + 상태변경함수를 정의한다.
return <ReactContext.Provider value={ctxRC}>{children}</ReactContext.Provider>으로 컴포넌트에 상태로직 코드들을
뺴줄 수 있다.

8. context provider가 하나라면 state 변경할 떄 state 값을 받은 모든 컴포넌트가 변경된다.
=> react context의 가장 큰 단점이다.

9. 로직을 분리하고 provider를 분리하면 컴포넌트 재실행을 컨트롤할 수 있다.
=> 그러나 모든 상태를 그렇게 관리하기에는 가독성이 떨어진다.

10. 그래서 redux나 recoil을 사용한다.


*** Context.Provider value로 덮힌 컴포넌트들이 useContext를 통해 저장소에 접근할 수 있다. => children +
*** createContext의 변수명, value의 변수명이 같아야 한다. => 제일 중요, 이것 떄문에 오류난다.