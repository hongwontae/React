1. ref
1-1. ref은 상태가 아닌 리액트가 관리하는 값이다.
1-2. useRef()로 생성할 수 있다.
1-3. ex) const divRef = useRef();

1-4. JSX element와 연결할 수 있다.
1-5. 모든 리액트 컴포넌트에서 사용이 가능하다.
1-6. 내장 컴포넌트 input에 ref을 연결하면 참조 변수는 input.current로 해당 DOM에 접근이 가능하다.
1-7. 빈번한 상태 변화를 대체하고 간결한 코드를 작성하게 도와준다.


2. ref와 React
2-1. ref는 직접 DOM 요소에 접근하는 것이다. 값에 접근하여 값을 전달하는 목적은 유용하다.
2-2. but ref을 통해 직접 dom을 조작하는 것은 에러가 발생하거나 좋지 못한 접근이다.
2-3. 그러나 value=''을 초기화하는 작은 작업의 경우 성공할 수 있고 전체 상태에 영향을 주지 않는다면 괜찮다.
2-4. 첫 컴포넌트 렌더링 사이클에서 컴포넌트 함수가 처음 실행될 떄 useRef에 연결된 ref.current는 undefined이다.
=> 컴포넌트가 재 시작되었을 떄 연결되어 값을 가진다.


3. Ref-State
3-1. 참조가 바뀔 떄마다 컴포넌트가 재실행되지 않는다.
3-2. State는 값이 변경될 떄마다 컴포넌트가 재실행된다.


4. ref +
4-1. 컴포넌트가 재평가되면 모든 변수, 함수들이 재생성된다. => 기존의 변수가 재생성되어 값이 초기화가 된다.
=> 원치 않는 작업
4-2. 재평가를 피하기 위해 컴포넌트 함수 밖으로 변수나 함수를 밖에서 선언한다.
=> 모든 인스턴스들이 해당 변수를 참조해버린다. => 원치 않는 작업

4-3. ref는 어떤 종류의 값이든 제어하기 위해 사용될 수도 있다.
=> 컴포넌트가 재평가되어도 값을 초기화하지 않는다.
=> 컴포넌트 함수 안에서 사용되었기 떄문에 각자의 인스턴스에 해당 변수가 종속된다.

4-4. ref을 자식에게 전달하여 자식 컴포넌트에 ref을 연결시키고 부모가 ref을 사용하고 싶다면?
=> forwardRef을 사용해야 한다.
=> forwardRef을 통해 함수를 감싸고 ref을 두 번째 매개변수로 받는다.


5. dialog Dom
5-1. <dialog></dialog>;
5-2. dialog 기본적으로 open={false}이다.
5-3. 내장 backdrop이 존재한다./ dialog을 open props을 인위적으로 주면 backdrop이 사라진다.
5-4. dialog.showModal() => 호출하면 dialog가 backdrop을 가진채 표시된다.
5-5. dialog가 html 코드 상에 존재하면 보이지 않을 뿐이다. 
5-6. onClose 속성은 esc를 눌렀을 떄 꺼지는 속성이다. => 해당 속성을 이용해서 modal 사라진 상태도 넣어줘야 한다.


8. Portals
8-1. import {createPortal} from 'react-dom';
8-2. 컴포넌트에 렌더링이 될 HTML 코드를 DOM 내에 다른 곳으로 옮기는 함수이다.
8-3. createPortal(JSX, 옮길 장소) => 옮길 장소는 document.querySelector/getElementById..로 찾는다.
8-4. Modal의 경우 HTML 위치가 맨 위나 맨 아래에 위치하는 것이 좋다. => 코드 상에서







 