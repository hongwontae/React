1. ref
1-1. ref은 상태가 아닌 리액트가 관리하는 값이다. (일반적인 값으로 사용하든가, dom의 연결값으로 사용하든가)
1-2. useRef()로 생성할 수 있다.
1-3. ex) const divRef = useRef();

1-4. JSX element와 연결할 수 있다.
1-5. 모든 리액트 컴포넌트에서 사용이 가능하다.
1-6. 내장 컴포넌트 input에 ref을 연결하면 참조 변수는 input.current로 해당 DOM에 접근이 가능하다.
1-7. 빈번한 상태 변화를 대체하고 간결한 코드를 작성하게 도와준다.


2. ref와 React
2-1. ref는 직접 DOM 요소에 접근하는 것이다. 값에 접근하여 값을 전달하는 목적은 유용하다.
2-2. but ref을 통해 직접 dom을 조작하는 것은 에러가 발생하거나 좋지 못한 접근이다.
2-3. 그러나 value=''을 초기화하는 작은 작업의 경우 성공할 수 있고 전체 상태에 영향을 주지 않는다면 괜찮다.
2-4. 첫 컴포넌트 렌더링 사이클에서 컴포넌트 함수가 처음 실행될 떄 useRef에 연결된 ref.current는 undefined이다.
=> 컴포넌트가 완전히 실행되고 나서부터 연결이 되는 것이다. 코드가 위에서 아래로 파싱한다 것을 이해하면 쉽다.


3. Ref-State
3-1. 참조가 바뀔 떄마다 컴포넌트가 재실행되지 않는다.
3-2. State는 값이 변경될 떄마다 컴포넌트가 재실행된다.


4. ref +
4-1. 컴포넌트가 재평가되면 모든 변수, 함수들이 재생성된다. => 기존의 변수가 재생성되어 값이 초기화가 된다.
=> 원치 않는 작업
4-2. 재평가를 피하기 위해 컴포넌트 함수 밖으로 변수나 함수를 밖에서 선언한다.
=> 모든 인스턴스들이 해당 변수를 참조해버린다. => 원치 않는 작업

4-3. ref는 어떤 종류의 값이든 제어하기 위해 사용될 수도 있다.
=> 컴포넌트가 재평가되어도 값을 초기화하지 않는다.
=> 컴포넌트 함수 안에서 사용되었기 떄문에 각자의 인스턴스에 해당 변수가 종속된다.

4-4. ref을 자식에게 전달하여 자식 컴포넌트에 ref을 연결시키고 부모가 ref을 사용하고 싶다면?
=> forwardRef을 사용해야 한다.
=> forwardRef을 통해 함수를 감싸고 ref을 두 번째 매개변수로 받는다.







 