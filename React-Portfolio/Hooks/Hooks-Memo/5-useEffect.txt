1. 부수효과란?
1-1. 컴포넌트의 JSX의 렌더링과 직접적인 연관이 없는 효과를 의미한다.
1-2. 해당 컴포넌트가 전부 렌더링 된 이후에 발생하는 함수를 의미한다.
1-3. 부수효과가 존재한다고 해서 useEffect을 사용할 필요는 없다. => 무한 루프의 여부가 중요하다.


2. useState로 부수효과를 처리했을 떄의 단점
2-1. setState()을 계속 호출하기 떄문에 무한 루프를 야기시킨다.
2-2. useEffect을 사용해야 한다.


3. useEffect();
3-1. useEffect의 콜백 함수의 실행시점은 컴포넌트가 렌더링 된 이후이다.
3-2. 첫 번쨰 인자로는 콜백 함수, 두 번쨰 인자는 의존성 배열을 받는다.

3-3. useEffect(()=>{})
=> 컴포넌트가 마운트 된 이후, 컴포넌트가 업데이트 된 이후에 실행된다.

3-4. useEffect(callBackFunc, []);
=> 컴포넌트가 최초로 마운트될 때만 콜백 함수가 실행된다.

3-5. useEffect(callBackFunc, [state]);
=>  컴포넌트가 최초로 마운트될 때 + 의존성 배열에 넣어준 state가 변경되었을 때 콜백 함수가 실행된다.

3-6. useEffect(callBackFunc, {return(() => func())};
=>  컴ㅍ넌트가 최초로 마운트 될 떄, 컴포넌트가 업데이트 된 이후, 컴포넌트가 언마운트 되기 전에 실행

3-7. useEffect(()=>{... return ()=>{}}, [...])
=> 컴포넌트 최초 마운트 + 의존성 배열의 값이 변경되었을 떄 콜백 함수가 실행되는데 그 전에 clean-up 함수가 실행된다.
=> 언 마운트 때 실행된다.

3-8. 컴포넌트 함수 렌더링 => useEffect() 콜백 함수 실행 => 해당 흐름은 3~7까지 모두 실행된다.

=> 컴포넌트 함수 실행 => useEffect가 실행 => useEffect 내에서 state 변경이 로직이 없다면 거기서 끝나는 것이다.


6. ref와 DOM-API
6-1. 첫 컴포넌트 사이클에서 ref의 연결은 JSX코드가 반환되기 전까지 연결되지 않는다.
6-2. useEffect()의 콜백함수로 ref-Dom-Api를 사용하면 컴포넌트가 실행되고 JSX가 반횐되고 나서 실행되기 때문에
확실한 연결을 보장해준다.


7. Effect Dependencies
7-1. useEffect 안에서 사용하는 컴포넌트 함수를 다시 실행하도록 하는 값을 의미한다.


8. useEffect와 시간 처리
8-1. setTimeout을 통해 어떤 값을 삭제하거나 추가하는 로직을 취소하려면 useEffect()와 함께 사용하는 것이 좋다.
8-2. useEffect의 return을 사용한다.


9. JS의 함수는 객체이기 떄문에 리렌더링시에 재생성되는 것이다.
=> 그렇기에 useEffect의 의존성 배열로 props의 함수를 받는 것는 위험하다.
=> 컴포넌트 재평가 => 함수의 재생성이기 떄문이다.