React 2강
이벤트 핸들링, State

모든 태그들은 내장된 html 요소에서 우리가 수신할 수 있는 이런 모든 DOM 이벤트에 접근할 수 있다.

리액트는 모든 기본 이벤트를 on으로 시작하는 props로 노출한다.
이벤트 발생 => on이라는 props를 사용한다. 이벤트는 항상 함수를 받아서 실행한다.
=> 이것이 리액트 이벤트 리스너를 추가하는 방법이다.
jsx의 onclick에 함수를 직접적으로 넣는 방법도 있지만 return문 위에서 규정하는 방식이 가독성에 좋아 대부분
위에서 작성한다.

함수를 생성하고 jsx 내의 이벤트리스너에 함수를 건네주는데 ()뺴고 보낸다
만약 괄호를 추가한 채 보낸다면 이 코드 라인들이 분석되었을 떄 js가 해당 코드를 실행한다. 그리고 jsx 코드가 반환될 때 해당 코드 라인이 분석된다 그래서 클랙했을 때 이벤트가 실행되는 것이 아니라 jsx코드가 평가될 때 실행된다. () 사용하면 미리 작동해서 안된다. 그래서 지정만 해주어야 한다. 리액트가 알아서 지정한 함수를 알맞게 실행한다.

모든 html 태그에서 지원되는 이벤트 리스너를 추가할 수 있다. 모든 것은 Dom동작에 기반한다.
개발자의 불문율로 이벤트 리스너 이름은 리스너명+Handler로 끝낸다.


지금의 리액트 컴포넌트는 함수형이다. 그 컴포넌트는 jsx를 반환한다. 그리고 우리는 그 함수를 호출해야 한다. 반응하게 하려면.. 하지만 우리는 함수를 호출한 적이 없다
리액트는 jsx에서 마주치는 컴포넌트 함수들을 계속해서 호출한다.
=> 무슨 말을 하고 있는 거냐면 우리가 만든 scf 함수를 태그로 만든다. 최상위 컴포넌트에서 하위 컴포넌트 함수를 호출한다는 의미이다.
리액트는 절대 반복하지 않는다
리액트는 응용프로그램이 처음 랜더링되었을 때 모든 과정을 실행하고 그 이후에는 끝이다.


state
클릭했을 떄나 변수가 바뀌었을 때나 컴포넌트 함수를 다시 실행하라고 트리거하지 않는다.
리액트에게 다시 렌더링하라고 말하려면 useState사용

UseState => 컴포넌트 함수가 다시 호출되는 곳에서 변경된 값을 반영하기 위해 state로 값을 정의할 수 있게 해주는 함수이다
이 함수는 컴포넌트 함수안에서 선언할 수 있다. 그 외에는 불허한다.
useState는 첫 번쨰 값이 변수 자체인 배열을 반환하고 배열에서 두 번째 요소는  업데이트 되는 함수이다.
그리고 여기 js 배열 구조 분해 기능을 활용한다.
첫 번쨰 값은 관리되고 있는 값을 가리킨다. 두 번째 값은 새로운 title을 설정하기 위해 호출할 수 있는 함수가 된다.
함수를 호출하는 것은 어떤 변수에 새로운 값을 할당하는 것이 아니라 대신 이 특별한 변수로 시작하기 때문이다. => const [title, setTitle] = useState(props.title) 이 useState는 메모리을 갖고 리액트로 관리된다. state를 업데이트하는 함수를 호출할 떄 setTitle은 단지 새로운 값만 받는 것이 아니다.
=> 그니까 useState가 있으면 다시 실행시켜준다.

console.log는 바뀌기 전의 변수르 보여주는데 왜냐하면 state를 업데이트하는 함수를 호출했을 떄 사실상 바로 값을 바꾸지 않았기 떄문이다 대신 state 업데이트를 예약한다 

다시 업데이트를 할 떄 state가 등록된 컴포넌트만 재평가한다.

expense.js는 네개의 ExpenseItem을 갖고 있다. 4개의 expenseItem은 별도의 state을 갖고 있다.
그래서 ExpenseItem을 구현하는 곳에서 state가 바껴도 해당 하는 컴포넌트만 변경된다
=> state는 컴포넌트의 인스턴스 별로 별도의 State를 갖는 것이다.
  

 comst를 사용하지 않는 이유
등호를 사용해서 값을 할당하지 않는다.
jsx 태그의 속성에서 OnClick같은 이벤트를 실행하면 함수를 실행하고 setTitle이 나오면 다시 reLoad하는 형식이다.

const [title, setTitle] = useState(props.title) 
=> 처음 렌더링할 때는 이벤트가 발생하지 않는다. useState(초기값)으로 화면이 나온다.
=> 이벤트가 발생하면 setTitle의 효과를 받아서 실행한다.

초기값은 주어진 컴포넌트 인스턴스에 대해 처음으로 컴포넌트형 함수가 실행될 때만 고려되는 값이다.

onChange => 모든 입력 타입에 같은 이벤트를 사용할 수 있다는 것이다.

바닐라 JS? 리액트가 빠진 js를 의미한다.

우리가 이벤트를 정의할 때 자동적으로 매개변수에 이벤트를 규정하는 event 매개객체를 받을 수 있다.
리액트나 브라우저에서 이벤트가 발생했을 떄 자동적으로 이벤트 객체를 받을 수 있게 동작한다.

이벤트는 다수의 데이터를 포함하는데 target필드가 있다는 것이 중요하다
이 target은 간단히 이벤트가 일어나는 dom요소를 가리킨다. 지금 같은 경우는 input를 뜻한다.
그리거 input에는 value가 존재하는 이 value가 뜻하는 것은 input에 적어놓은 것들을 보여준다.

우리가 해야될 목표는 input에서 받은 것을 이용하는 것이다.
함수가 실행하여 리렌더링 될 떄 값을 저장하고 싶으면 useState을 사용한다.
이 경우의 초기값은 ('')이다. input값이 입력되지 않았기 때문이다.

우리는 여러 상태, 여러 개의 상태 조각들 또는 컴포넌트 별로 상태 조각들을 가질 수 있다. 그리고 같은 컴포넌트 안에 있는 이 모든 상태들은 완전히 별개의 것들이다.

input에서 target.value로 얻는 값들은 전부 문자열이다.

지금까지 내가 했던 방향은 state을 세 개 만들어서 input의 상태변화를 3번 한 것이다.
state를 한번만 가는 방법도 있다.


state 객체로 전달하는 방식?
useState의 값으로 객체를 전달한다 
State을 업데이트 할 때마다 한 개가 아니라 세 프로퍼티 모두를 업데이트 해야 한다. 

const [date, setDate] = useState({start : null, end :null})
const date = { start : null, end : null } => 이런 형식으로 값이 부여된 것이다.

const [startDate, setStartDate] = useState(null)
const [endDate, setEndDate] =  useState(null)
본래는 이런 형식이었다.

이 같은 형식을 사용하여 set으로 변경사항을 알릴 때 나머지들의 데이터들을 잃어버리지 않도록 꼭 확인해야 한다. 만약 set를 적용하면 기본적으로 다른 키들은 버리게 된다. 왜냐하면 state을 업데이트 할 떄 리액트은 이전 state와 병합하지 않기 때문이다.
이 방식은 기존의 데이타를 잃어버리지 않기 위헤 state 스냅샷에 의존하고 그런 다음 새로운 값을 오버라이딩한다.

위의 방식보다 setUserInput에 함수를 주는 것이 더 좋다 set에 준 함수는 리액트에 의해 자동으로 실행된다.
함수의 매개변수는 기존의 state값을 받는다
   //     setUserInput((pervState)=>{
    //         return{...pervState, enteredTitle : event.target.value}
    //     })

폼 submit을 누를 때마다 서버에 요청을 페이지가 리로딩된다.
=> 우리가 원하는 것은 폼으로 데이터를 받아서 화면에 띄우는 것이다.
event.preventDefault로 막는다. 로드된 페이지에 남는다.

우리가 값을 계속해서 사용하길 원한다면 전역변수로 사용해야 한다.
값을 저장하는 것은 useState의 첫 객체이다.

양방향 바인딩 => 변경되는 입력값만 수신하는 것이 아니라 입력에 새로운 값을 다시 전달할 수 도 있다.
입력값을 초기화하는 방식이 이에 해당한다.
상태를 변경하면 입력도 변한다.

expenseform에서 생성한 데이터를 app 컴포넌트에 전달해야 한다.
자체 이벤트 속성을 생성해서 값으로 함수를 가질 수 있고 부컴에서 자컴으로 함수를 전달할 수 있게 해줄 것이고 자식 컴포넌트에서 그 함수를 호출할 수 있다. 그리고 함수를 호출했을 떄 그 함수에 매개변수로 데이터를 전달할 수 있다.

속성은 오로지 부모에서 자식으로만 전달될 수 있다. 중간 컴포넌트 생략이 불가능하다.
	
부모 컴포넌트에 함수를 만들어서 사용자 정의로 보내주고 자식 컴포넌트에서 함수를 실행하면 자식에서 부모로 데이타를 주는 효과를 줄 수 있다.

value? => 모든 입력 요소들이 갖는 내부 값의 프로퍼티를 설정한다.

props를 사용해서 부모 컴포넌트로부터 함수를 받고 자식 컴포넌트에서 그 함수를 불러왔다.
State 끌어올리기
















