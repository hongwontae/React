1. loader
1-1. 백엔드와 통신하는 라우터가 존재할 경우 해당 라우터에 도착할 떄 http 통신을 실행한다.
=> 라우터에 컴포넌트를 렌더링하기 전에 loader를 사용해서 통신을 한 뒤 데이터로 렌더링해보자.

1-2. createBrowser 배열 객체 안에 loader props를 사용할 수 있다. 함수를 value로 받는다.
1-3. 해당 라우터를 방문하기 직전에 R-R-D은 항상 loader를 실행시킬 것이다.
=> 렌더링 전/ JSX 코드가 렌더링되기 전에 실행된다.

1-4. loader 함수에 return 값은 loader를 가지고 있는 path의 element가 취할 수 있다.
1-5. 또한 다른 element에게 전달할 수 도 있다.
=> async 내부의 함수이기 떄문에 return 값이 Promise에 담겨지는게 정석이지만 router 라이브러리가 알아서 리졸브된
값을 가져온다.

1-6. loader를 정의하면 useLoaderData를 통해 데이터를 가져올 수 있다.
=> 같은 레벨의 element, 해당 컴포넌트로부터의 자식 레벨의 element, 부모는 불가능


1-7. loader의 위치는 라우트를 정의하는 곳이 아니라 Router 컴포넌트에서 구현하고 export를 통해 해결한다.
=> 정석


1-8. RootRouterCompoennt => switch another RouterCom => loader 실행(다만 loader의 함수 실행이 끝나기 전까지 
another Router로 가지 못하고 RootRouter에 머물러 있다고 loader가 완료되면 another로 이동) => 다른 route 컴포넌트


2. useNavigation
=> 현재 라우터가 전환이 진행되는지, 데이터 로딩하는 중인지, 전환이 진행되지 않는지를 알 수 있다.
=> 이를 훅은 전환된 페이지가 아니라 전환 전 페이지에 알맞은 데이터가 전송된다.

=> const navi = useNavigation();
=> navi.state : idle, loading, submmitted 상태가 존재한다.


3. new Response();
=> 브라우저 내장 객체이고 응답 객체를 생성해준다.


4. loader 에러처리

4-1. loader 안에서 에러를 트리거하고 에러가 발생하면 객체를 반환한다.
=> 해당 객체를 통해서 에러 JSX를 반환하는 로직

4-2. throw를 사용한다.
=> loader 함수 실행 중에 throw가 트리거되면 errorElement로 전환한다.
=> errorElement는 자신과 가장 가까운 errorElement를 트리거한다.
=> 부모 errorElement로 올라간다. => 자식 errorElement는 의미없다.
