1. 리액트 실행 순서
1-1. APP Function이 실행된다.
1-2. App.jsx의 JSX가 실행된다.
=> 이 떄 DOM과 커스텀 컴포넌트들이 존재한다.
=> 커스텀 컴포넌트를 만나면 그 안에 모든 것을 실행하기 전까지 밑의 JSX로 내려가지 않는다.


2. import {memo} from 'react';
2-1. memo는 컴포넌트 함수를 덮는 함수이다.
2-2. 부모 컴포넌트가 재실행되었다. => memo로 덮여진 컴포넌트는 부모가 내려준 props가 변경되었다면 재실행한다. 그러나
props가 같은 값이라면 재실행하지 않는다.


3. 상태 변화를 일으키는 컴포넌트의 재배치를 통해 부모 - 자식 관계를 피하려 재실행을 피할 수 있다.


4. props로 내려준 dom이나 내장 컴포넌트는 재실행, 재생성되지 않는다.


5. useCallback()
=> 컴포넌트가 재실행될 떄 컴포넌트에서 작성된 함수들도 재실행된다.
=> 이 때 useCallback으로 덮으면 해당 함수는 재실행되지 않는다.
=> 재실행되지 않았다는 것은 동일한 콜스택 값을 유지한다는 것이다.


6. useMemo()
=> 일반 함수의 재 호출을 방지할 떄 사용하는 Hooks
=> useMemo의 첫 번쨰 인자의 구조는 ()=>{방지할 함수()}, 두 번쨰 인자는 의존성 배열이다.


7. 컴포넌트 함수 실행 => jsx 반환 => 컴포넌트 트리 생성 => native HTML 요소 => HTML DOM에 삽입 (div id root에 들어가는 행위)
7-1. 컴포넌트 함수가 재실행된다해도 모든 JSX 코드가 DOM으로 재삽입되지 않는다.
7-2. elements의 깜빡이는 요소만 변경된다. 다른 요소는 리액트에 간섭받지 않는다.

7-3. virtual dom
=> 메모리 안에만 존재한다.
=> DOM에 삽입되기 전에 Virtaul DOM을 생성한다.
=> 컴포넌트가 재실행될 떄마다 virtual DOM까지 간다.
=> 이 후 가장 최근 Virtaul dom과 재실행한 Virtaul dom을 비교한 뒤 바뀌 컨텐츠만 DOM에 적용한다.


8. key Props
상태는 컴포넌트 안에 속해 있기 떄문에 재사용이 가능하다.

key 특징
8-1. 상태는 리액트가 위치에 따라 추적한다. => 컴포넌트 유형이 중요하다.
리액트는 동적인 목록을 반환할 떄 key를 필요로 한다. => 리액트가 동적 목록을 확실히 식별하는 방법이기 떄문이다.

동적인 목록 반환에 key에 index를 주면 안된다. => 목록을 제대로 식별하지 않기 떄문이다.
새로운 배열이 동적으로 반환되면 => 목록에 기존에 부여했던 인덱스가 달라지기 떄문에 의도치 않은 동작이나 에러가 발생할 수 있다.


8-2. key Props의 값을 index로 주면 렌더링 성능에 저하를 일으킨다.
=> index을 주게 되면 동적인 목록이 새롭게 렌더링되면 index 전체가 바뀐다.
 => 이는 리액트가 전체적인 변화로 인식하기 떄문에 모든 목록을 리렌더링한다. 그렇기 때문에 변하지 않는 key value를 부여해야 한다.


8-3. useState에 전달되는 초기값은 컴포넌트 함수의 첫 실행 이후로 다시 사용되지 않는다.
=> props로 받은 값이든, 어떻게든 값이 변경되어서 컴포넌트가 재실행되었다. => 변경된 값이 기존의 state의 초기값으로 사용되었다.
=> 이런 상황에서는 useState의 초기값 할당이 또 다시 이루어지지 않는다. => 기본 원칙이다.

8-4. 그러나 변경된 값을 가지고 있는 컴포넌트의 인스턴스가 완전히 삭제되고 재탄생하여 실행된다면?
=> useState의 값의 초기화가 이루어지지 않았을 것이고 초기화 된다.
=> 해당 커스텀 컴포넌트에 key props를 주면 된다.
=> 주의할 점은 같은 레벨의 인스턴스에 같은 key={value}를 가지면 에러가 발생한다.
